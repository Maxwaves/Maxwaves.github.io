{"meta":{"title":"ArgsのBlog","subtitle":"Maxwaves","description":"Welcome to my blog","author":"Maxwaves","url":"http://example.com","root":"/"},"pages":[{"title":"gallery","date":"2022-01-10T11:41:48.000Z","updated":"2022-01-10T11:47:02.164Z","comments":true,"path":"Gallery/index.html","permalink":"http://example.com/Gallery/index.html","excerpt":"","text":"壁纸 收藏的一些壁纸 漫威 关于漫威的图片 OH MY GIRL 关于OH MY GIRL的图片"},{"title":"categories","date":"2022-01-10T11:32:55.000Z","updated":"2022-01-10T11:35:03.081Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2023-04-09T11:03:00.542Z","updated":"2022-02-21T05:02:04.303Z","comments":true,"path":"css/calendar.css","permalink":"http://example.com/css/calendar.css","excerpt":"","text":".calendar { font-family: Helvetica, arial; border: 1px solid #dddddd; border-radius: 3px; min-height: 120px; text-align: center; margin: 0 auto; border-width: 0px; width: 100%; display: flex; display: -webkit-flex; justify-content: center; align-items: center; flex-wrap: wrap; } .calendar-graph text.wday, .calendar-graph text.month { font-size: 10px; fill: #aaa; } .contrib-legend { text-align: right; padding: 0 14px 10px 0; display: inline-block; float: right; } .contrib-legend .legend { display: inline-block; list-style: none; margin: 0 5px; position: relative; bottom: -1px; padding: 0; } .contrib-legend .legend li { display: inline-block; width: 10px; height: 10px; } .text-small { font-size: 12px; color: #767676; } .calendar-graph { padding: 5px 0 0; text-align: center; } .contrib-column { text-align: center; border-left: 1px solid #ddd; border-top: 1px solid #ddd; font-size: 11px; } .contrib-column-first { border-left: 0; } .table-column { padding: 10px; display: table-cell; width: 33%; vertical-align: top; } .contrib-number { font-weight: 300; line-height: 1.3em; font-size: 24px; display: block; color: #333; } .calendar img.spinner { width: 70px; margin-top: 50px; min-height: 70px; } .monospace { text-align: center; color: #000; font-family: monospace; } .monospace a { color: #1d75ab; text-decoration: none; } .contrib-footer { font-size: 11px; padding: 0 10px 12px; text-align: left; width: 100%; box-sizing: border-box; height: 26px; } .left.text-muted { float: left; margin-left: 9px; color: #767676; } .left.text-muted a { color: #4078c0; text-decoration: none; } .left.text-muted a:hover, .monospace a:hover { text-decoration: underline; } h2.f4.text-normal.mb-3 { display: none; } .float-left.text-gray { float: left; } #user-activity-overview { display: none; } .day-tooltip { white-space: nowrap; position: absolute; z-index: 99999; padding: 10px; font-size: 12px; color: #959da5; text-align: center; background: rgba(0, 0, 0, 0.85); border-radius: 3px; display: none; pointer-events: none; } .day-tooltip strong { color: #dfe2e5; } .day-tooltip.is-visible { display: block; } .day-tooltip:after { position: absolute; bottom: -10px; left: 50%; width: 5px; height: 5px; box-sizing: border-box; margin: 0 0 0 -5px; content: \" \"; border: 5px solid transparent; border-top-color: rgba(0, 0, 0, 0.85); } .position-relative { width: 100%; margin-left: 20px; margin-right: 20px; } @media screen and (max-width: 650px) { .contrib-column { display: none; } }"},{"title":"友链","date":"2022-01-12T05:31:07.000Z","updated":"2022-01-12T05:31:48.743Z","comments":true,"path":"friend/index.html","permalink":"http://example.com/friend/index.html","excerpt":"","text":""},{"title":"","date":"2023-04-09T11:03:00.543Z","updated":"2022-02-21T05:02:06.797Z","comments":true,"path":"js/calendar.js","permalink":"http://example.com/js/calendar.js","excerpt":"","text":"GitHubCalendar(\".calendar\", \"Maxwaves\"); // or enable responsive functionality GitHubCalendar(\".calendar\", \"Maxwaves\", { responsive: true });"},{"title":"标签","date":"2018-01-04T16:00:00.000Z","updated":"2022-01-10T09:25:18.114Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"相关链接","date":"2022-01-10T11:35:24.000Z","updated":"2022-01-12T05:20:37.871Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""},{"title":"","date":"2023-04-09T11:03:00.543Z","updated":"2022-02-21T05:02:05.153Z","comments":true,"path":"js/gitcalendar.js","permalink":"http://example.com/js/gitcalendar.js","excerpt":"","text":"\"use strict\"; var _typeof2 = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; var _typeof = \"function\" == typeof Symbol && \"symbol\" == _typeof2(Symbol.iterator) ? function (e) { return typeof e === \"undefined\" ? \"undefined\" : _typeof2(e); } : function (e) { return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e === \"undefined\" ? \"undefined\" : _typeof2(e); }; !(function (e) { \"object\" === (\"undefined\" == typeof exports ? \"undefined\" : _typeof(exports)) && \"undefined\" != typeof module ? (module.exports = e()) : \"function\" == typeof define && define.amd ? define([], e) : ((\"undefined\" != typeof window ? window : \"undefined\" != typeof global ? global : \"undefined\" != typeof self ? self : this ).GitHubCalendar = e()); })(function () { return (function o(s, u, i) { function c(t, e) { if (!u[t]) { if (!s[t]) { var r = \"function\" == typeof require && require; if (!e && r) return r(t, !0); if (l) return l(t, !0); var n = new Error(\"Cannot find module '\" + t + \"'\"); throw ((n.code = \"MODULE_NOT_FOUND\"), n); } var a = (u[t] = { exports: {} }); s[t][0].call( a.exports, function (e) { return c(s[t][1][e] || e); }, a, a.exports, o, s, u, i ); } return u[t].exports; } for ( var l = \"function\" == typeof require && require, e = 0; e < i.length; e++ ) { c(i[e]); } return c; })( { 1: [ function (e, t, r) { var h = e(\"github-calendar-parser\"), y = e(\"elly\"), v = e(\"add-subtract-date\"), M = e(\"formatoid\"), x = \"YYYY 年 MMM D 日\", _ = \"MMMM D\", S = [ \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\", ]; function k(e) { return e + \" \" + (1 === e ? \"day\" : \"天\"); } t.exports = function (b, e, m) { (b = y(b)), ((m = m || {}).summary_text = m.summary_text || '数据来源 @' + e + \"\"), (m.cache = 1e3 * (m.cache || 86400)), !1 === m.global_stats && (b.style.minHeight = \"175px\"); var r = { content: \"gh_calendar_content.\" + e, expire_at: \"gh_calendar_expire.\" + e, }; (m.proxy = m.proxy || function (e) { return fetch( \"https://api.bloggify.net/gh-calendar/?username=\" + e ).then(function (e) { return e.text(); }); }), (m.getCalendar = m.getCalendar || function (e) { if ( m.cache && Date.now() < +localStorage.getItem(r.expire_at) ) { var t = localStorage.getItem(r.content); if (t) return Promise.resolve(t); } return m.proxy(e).then(function (e) { return ( m.cache && (localStorage.setItem(r.content, e), localStorage.setItem( r.expire_at, Date.now() + m.cache )), e ); }); }); return (function g() { return m .getCalendar(e) .then(function (e) { var t = document.createElement(\"div\"); t.innerHTML = e; var r, n, a, o, s, u, i, c, l, d, f, p = t.querySelector(\".js-yearly-contributions\"); y(\".position-relative h2\", p).remove(), (p.querySelector(\".float-left.text-gray\").innerHTML = m.summary_text), p.querySelector(\"include-fragment\") ? setTimeout(g, 500) : (!0 === m.responsive && ((n = (r = p.querySelector( \"svg.js-calendar-graph-svg\" )).getAttribute(\"width\")), (a = r.getAttribute(\"height\")), r.removeAttribute(\"height\"), r.setAttribute(\"width\", \"100%\"), r.setAttribute(\"viewBox\", \"0 0 \" + n + \" \" + a)), !1 !== m.global_stats && ((s = (o = h(y(\"svg\", p).outerHTML)).current_streak ? M(o.current_streak_range[0], _) + \" 日\" + \" &ndash; \" + M(o.current_streak_range[1], _) : o.last_contributed ? \"最后一次提交于\" + \" \" + M(o.last_contributed, _) + \"\" : \"Rock - Hard Place\"), (u = o.longest_streak ? M(o.longest_streak_range[0], _) + \" 日\" + \" &ndash; \" + M(o.longest_streak_range[1], _) : o.last_contributed ? \"最后一次提交于\" + \" \" + M(o.last_contributed, _) + \" \" : \"Rock - Hard Place\"), (i = y(\"\", { class: \"contrib-column contrib-column-first table-column\", html: '过去一年内提交\\n ' + o.last_year + ' 次\\n ' + M( v.add( v.subtract(new Date(), 1, \"year\"), 1, \"day\" ), x ) + \" &ndash; \" + M(new Date(), x) + \"\", })), (c = y(\"\", { class: \"contrib-column table-column\", html: '最长连续提交记录\\n ' + k(o.longest_streak) + '\\n ' + u + \" 日\", })), (l = y(\"\", { class: \"contrib-column table-column\", html: '当前提交记录\\n ' + k(o.current_streak) + '\\n ' + s + \" 日\", })), p.appendChild(i), p.appendChild(c), p.appendChild(l)), (b.innerHTML = p.innerHTML), !0 === m.tooltips && ((d = b), (f = document.createElement(\"div\")).classList.add( \"day-tooltip\" ), d.appendChild(f), d.querySelectorAll(\"rect.day\").forEach(function (e) { e.addEventListener(\"mouseenter\", function (e) { var t = e.target.getAttribute(\"data-count\"); \"0\" === t ? (t = \"No contributions\") : \"1\" === t ? (t = \"1 contribution\") : (t += \" contributions\"); var r = new Date( e.target.getAttribute(\"data-date\") ), n = S[r.getUTCMonth()] + \" \" + r.getUTCDate() + \", \" + r.getUTCFullYear(); (f.innerHTML = \"\" + t + \" on \" + n), f.classList.add(\"is-visible\"); var a = e.target.getBoundingClientRect(), o = a.left + window.pageXOffset - f.offsetWidth / 2 + a.width / 2, s = a.bottom + window.pageYOffset - f.offsetHeight - 2 * a.height; (f.style.top = s + \"px\"), (f.style.left = o + \"px\"); }), e.addEventListener(\"mouseleave\", function () { f.classList.remove(\"is-visible\"); }); }))); }) .catch(function (e) { return console.error(e); }); })(); }; }, { \"add-subtract-date\": 2, elly: 4, formatoid: 6, \"github-calendar-parser\": 8, }, ], 2: [ function (e, t, r) { function n(a) { return function e(t, r, n) { switch (((r *= a), n)) { case \"years\": case \"year\": t.setFullYear(t.getFullYear() + r); break; case \"months\": case \"month\": t.setMonth(t.getMonth() + r); break; case \"weeks\": case \"week\": return e(t, 7 * r, \"days\"); case \"days\": case \"day\": t.setDate(t.getDate() + r); break; case \"hours\": case \"hour\": t.setHours(t.getHours() + r); break; case \"minutes\": case \"minute\": t.setMinutes(t.getMinutes() + r); break; case \"seconds\": case \"second\": t.setSeconds(t.getSeconds() + r); break; case \"milliseconds\": case \"millisecond\": t.setMilliseconds(t.getMilliseconds() + r); break; default: throw new Error(\"Invalid range: \" + n); } return t; }; } t.exports = { add: n(1), subtract: n(-1) }; }, {}, ], 3: [ function (e, t, r) { (t.exports.en = [ \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", ]), (t.exports.en.abbr = [ \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", ]), (t.exports.en.short = [\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\"]), (t.exports.fr = [ \"dimanche\", \"lundi\", \"mardi\", \"mercredi\", \"jeudi\", \"vendredi\", \"samedi\", ]), (t.exports.fr.abbr = [ \"dim\", \"lun\", \"mar\", \"mer\", \"jeu\", \"ven\", \"sam\", ]), (t.exports.fr.short = [\"di\", \"lu\", \"ma\", \"me\", \"je\", \"ve\", \"sa\"]), (t.exports.es = [ \"domingo\", \"lunes\", \"martes\", \"miercoles\", \"jueves\", \"viernes\", \"sabado\", ]), (t.exports.es.abbr = [ \"dom\", \"lun\", \"mar\", \"mir\", \"jue\", \"vie\", \"sab\", ]), (t.exports.es.short = [\"do\", \"lu\", \"ma\", \"mi\", \"ju\", \"vi\", \"sa\"]), (t.exports.it = [ \"Domenica\", \"Lunedi\", \"Martedi\", \"Mercoledi\", \"Giovedi\", \"Venerdi\", \"Sabato\", ]), (t.exports.it.abbr = [ \"Dom\", \"Lun\", \"Mar\", \"Mer\", \"Gio\", \"Ven\", \"Sab\", ]), (t.exports.it.short = [\"D\", \"L\", \"Ma\", \"Me\", \"G\", \"V\", \"S\"]), (t.exports = [ \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", ]), (t.exports.abbr = [ \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", ]), (t.exports.short = [\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\"]); }, {}, ], 4: [ function (e, t, r) { var n = e(\"iterate-object\"), a = e(\"sliced\"); function o(r, e) { return \"string\" == typeof r ? \""}],"posts":[{"title":"Dockerfile构建镜像","slug":"Dockerfile构建镜像","date":"2023-07-28T03:23:56.000Z","updated":"2023-07-28T03:28:01.538Z","comments":true,"path":"2023/07/28/Dockerfile构建镜像/","link":"","permalink":"http://example.com/2023/07/28/Dockerfile%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F/","excerpt":"","text":"简介我们在讲docker存储驱动的时候，了解到镜像实际上是分层结构。所以如果我们需要自己生成镜像，其实就是定制每一层的配置、文件等信息。 在前面我们讲镜像的基本操作的时候，学习过如何使用docker commit来提交一个新的镜像。然而事实上，在生产环境中，使用docker commit来生成镜像的方式并不常用。一个原因是这种方式需要手动创建，容易出错，效率低且可重复性弱。再一个使用者不知道镜像是如何创建出来的，里面是否有恶意程序，可能存在安全隐患。 所以更好的方式是我们把每一层的修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、生成镜像。而这个脚本就是Dockerfile。 Dockerfile简单示例下面的示例是利用dockerfile生成一个ssh镜像，当然没什么实际意义： 1234567891011121314151617181920# cat DockerfileFROM ubuntu:16.04MAINTAINER yanwei &lt;yanwei@douyu.tv&gt;## install sshADD sources.list /etc/apt/sources.listRUN apt update &amp;&amp; \\ apt-get install openssh-server -y## config sshRUN mkdir /var/run/sshd &amp;&amp; \\ useradd -s /bin/bash -m -d /home/yanwei yanwei &amp;&amp; \\ echo &#x27;yanwei:123456&#x27;|chpasswdENV RUNNABLE_USER_DIR /home/yanweiEXPOSE 22CMD [&quot;/usr/sbin/sshd&quot;, &quot;-D&quot;] 生成镜像： 1docker build -t openssh:v1.0 . Dockerfile的组成Dockerfile分为四部分： 基础镜像信息 维护者信息 镜像操作指令 容器启动时执行指令 Dockerfile指令说明FROM 引入基础镜像格式为FROM &lt;image&gt;或者FROM &lt;image&gt;:&lt;tag&gt; 第一条指令必须为FROM指令。并且，如果在同一个Dockerfile中创建多个镜像时，可以使用多个FROM指令(每个镜像一次)示例： 1FROM centos:6.6 MAINTAINER 定义作者格式为MAINTAINER &lt;name&gt;，指定维护者信息示例： 1MAINTAINER Breeze Yan&lt;yan_ruo_gu@163.com&gt; ENV 设置环境变量格式： 12ENV &lt;key&gt; &lt;value&gt;ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt; ... 指定一个环境变量，会被后续RUN指令使用，并在容器运行时保持 示例： 12345ENV TZ &quot;Asia/Shanghai&quot;ENV TERM xtermENV k1=v1 k2=v2 \\ k3=v3 k4=v4 RUN 执行命令格式： 12RUN &lt;command&gt;RUN [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] 前者将在shell终端中运行命令，即/bin/sh -c；后者使用exec执行。每条RUN指令将在当前镜像基础上执行指定命令，并提交为新的镜像。当命令较长时，可以使用\\来换行。示例： 1RUN [&quot;/bin/bash&quot;, &quot;-c&quot;,&quot;echo hello&quot;] COPY 复制文件格式： 12COPY &lt;src&gt; &lt;dest&gt;COPY [&quot;&lt;src1&gt;&quot;,&quot;&lt;src2&gt;&quot;,...&quot;&lt;dest&gt;&quot;] 和 RUN 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。 COPY 指令将从构建上下文目录中 &lt;src&gt;的文件或目录复制到新的一层的镜像内的 &lt;dest&gt; 位置。&lt;src&gt;可以是多个，甚至可以是通配符，其通配符规则需要满足golang的filepath.Match规则。 &lt;dest&gt; 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。 此外，还需要注意一点，使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。 示例： 123COPY package.json /usr/src/app/COPY hom* /mydir/COPY hom?.txt /mydir/ ADD 更高级的复制文件ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。 比如 &lt;src&gt; 可以是一个 URL，这种情况下，Docker 引擎会试图去下载这个链接的文件放到 &lt;dest&gt; 去。下载后的文件权限自动设置为 600，如果这并不是想要的权限，那么还需要增加额外的一层 RUN 进行权限调整，另外，如果下载的是个压缩包，需要解压缩，也一样还需要额外的一层 RUN 指令进行解压缩。所以不如直接使用 RUN 指令，然后使用 wget 或者 curl 工具下载，处理权限、解压缩、然后清理无用文件更合理。因此，这个功能其实并不实用，而且不推荐使用。 如果&lt;src&gt;为一个 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，ADD 指令将会自动解压缩这个压缩文件到 &lt;dest&gt; 去。如果我们真的是希望复制个压缩文件进去，而不解压缩，这时就不可以使用 ADD 命令。在docker官方的最佳实践中要求，尽可能的使用 COPY，因为 COPY 的语义很明确，就是复制文件而已，而 ADD 则包含了更复杂的功能，其行为也不一定很清晰。最适合使用 ADD 的场合，就是需要自动解压缩的场合。 示例： 123ADD aliyun-mirror.repo /etc/yum.repos.d/CentOS-Base.repoADD aliyun-epel.repo /etc/yum.repos.d/epel.repoADD test.tar.gz / VOLUME 定义匿名卷格式： 12VOLUME [&quot;&lt;path1&gt;&quot;, &quot;&lt;path2&gt;&quot;...]VOLUME &lt;path&gt; 容器运行时应该尽量保持容器存储层不发生写操作，对于数据库类需要保存动态数据的应用，其数据库文件应该保存于卷(volume)中，为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在Dockerfile中，我们可以事先指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据。相当于容器启动时使用的-v选项，只不过这里不能指定挂载到宿主机的位置。 示例： 1VOLUME /data EXPOSE 声明端口格式： 1EXPOSE &lt;port1&gt; [&lt;port2&gt;...] EXPOSE 指令是声明运行时容器提供服务端口，这只是一个声明，在运行时并不会因为这个声明应用就会开启这个端口的服务。在 Dockerfile 中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个用处则是在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。 要将 EXPOSE 和在运行时使用 -p &lt;宿主端口&gt;:&lt;容器端口&gt; 区分开来。-p，是映射宿主端口和容器端口，换句话说，就是将容器的对应端口服务公开给外界访问，而 EXPOSE 仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。 示例： 1EXPOSE 80 443 WORKDIR 指定工作目录格式: 1WORKDIR /path/to/workdir 使用 WORKDIR 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录。可以使用多个WORKDIR指令，后续命令如果参数是相对路径，则会基于之前命令指定的路径。 示例： 1234# 最终路径为/a/b/cWORKDIR /aWORKDIR bWORKDIR c USER 指定当前用户格式： 1USER &lt;username&gt; USER 指令和WORKDIR相似，都是改变环境状态并影响以后的层。WORKDIR是改变工作目录，USER则是改变之后层的执行RUN, CMD 以及ENTRYPOINT这类命令的身份。当服务不需要管理员权限时，可以通过该命令指定运行用户。并且可以在之前创建所需要的用户。要临时获取管理员权限时可以使用gosu。 示例： 12345678# 建立 redis 用户，并使用 gosu 换另一个用户执行命令RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis# 下载 gosuRUN wget -O /usr/local/bin/gosu &quot;https://github.com/tianon/gosu/releases/download/1.7/gosu-amd64&quot; \\ &amp;&amp; chmod +x /usr/local/bin/gosu \\ &amp;&amp; gosu nobody true# 设置 CMD，并以另外的用户执行CMD [ &quot;exec&quot;, &quot;gosu&quot;, &quot;redis&quot;, &quot;redis-server&quot; ] CMD 容器启动命令支持三种格式： 123CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] #使用exec执行，推荐的方式CMD command param1 param2 #在/bin/sh中执行，提供给需要交互的应用CMD [&quot;param1&quot;,&quot;param2&quot;] #提供给ENTRYPOINT的默认参数 Docker不是虚拟机，事实上容器就是进程。既然是进程，那么在启动容器的时候，需要指定所运行的程序及参数。CMD 指令就是用于指定默认的容器主进程的启动命令的。 在运行时可以指定新的命令来替代镜像设置中的这个默认命令，比如ubuntu镜像默认的CMD是 /bin/bash，如果我们直接 docker run -it ubuntu 的话，会直接进入bash。我们也可以在运行时指定运行别的命令，如 docker run -it ubuntu cat /etc/os-release。这就是用 cat /etc/os-release 命令替换了默认的 /bin/bash 命令了，输出了系统版本信息。 在指令格式上，一般推荐使用exec方式执行，这类格式在解析时会被解析为JSON数组，因此一定要使用双引号 “，而不要使用单引号。 如果使用/bin/shy方式执行的话，实际的命令会被包装为 sh -c 的参数的形式进行执行。比如： 1CMD echo $HOME 在实际执行中，会将其变更为： 1CMD [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; ] 每个Dockerfile只能有一条CMD命令。如果指定了多条，只有最后一条会被执行。 示例： 1CMD [&quot;supervisord&quot;,&quot;-c&quot;,&quot;/etc/supervisord.conf&quot;] ENTRYPOINT 入口点格式： 12ENTRYPOINT [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]ENTRYPOINT command param1 param2 (shell中执行) ENTRYPOINT 的格式和 RUN 指令格式一样，分为 exec 格式和 shell 格式。 ENTRYPOINT 的目的和 CMD 一样，都是在指定容器启动程序及参数。ENTRYPOINT 在运行时也可以替代，不过比 CMD 要略显繁琐，需要通过 docker run 的参数 –entrypoint来指定。 当指定了ENTRYPOINT后，CMD的含义就发生了改变，不再是直接的运行其命令，而是将CMD的内容作为参数传给 ENTRYPOINT 指令，换句话说实际执行时，将变为： 1&lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot; 那么有了 CMD 后，为什么还要有 ENTRYPOINT 呢？这种 &lt;ENTRYPOINT&gt; &quot;&lt;CMD&gt;&quot;有什么好处呢？ 场景1：让镜像变成像命令一样使用假设我们需要一个得知自己当前公网 IP 的镜像，那么可以先用 CMD 来实现： 12345FROM ubuntu:16.04RUN apt-get update \\ &amp;&amp; apt-get install -y curl \\ &amp;&amp; rm -rf /var/lib/apt/lists/*CMD [ &quot;curl&quot;, &quot;-s&quot;, &quot;http://ip.cn&quot; ] 假如我们使用 docker build -t myip . 来构建镜像的话，如果我们需要查询当前公网 IP，只需要执行： 1docker run myip 这么看起来好像可以直接把镜像当做命令使用了，不过命令总有参数，如果我们希望加参数呢？比如从上面的 CMD 中可以看到实质的命令是 curl，那么如果我们希望显示 HTTP 头信息，就需要加上 -i 参数。那么我们可以直接加 -i 参数给 docker run myip 么？ 12docker run myip -idocker: Error response from daemon: invalid header field value &quot;oci runtime error: container_linux.go:247: starting container process caused \\&quot;exec: \\\\\\&quot;-i\\\\\\&quot;: executable file not found in $PATH\\&quot;\\n&quot;. 我们可以看到可执行文件找不到的报错，executable file not found。之前我们说过，跟在镜像名后面的是 command，运行时会替换 CMD 的默认值。因此这里的 -i 替换了原来的 CMD，而不是添加在原来的 curl -s http://ip.cn 后面。而 -i 根本不是命令，所以自然找不到。 那么如果我们希望加入 -i 这参数，我们就必须重新完整的输入这个命令： 1docker run myip curl -s http://ip.cn -i 这显然不是一个好的解决方案，而使用ENTRYPOINT就可以解决这个问题。现在我们重新用ENTRYPOINT来实现这个镜像： 12345FROM ubuntu:16.04RUN apt-get update \\ &amp;&amp; apt-get install -y curl \\ &amp;&amp; rm -rf /var/lib/apt/lists/*ENTRYPOINT [ &quot;curl&quot;, &quot;-s&quot;, &quot;http://ip.cn&quot; ] 这次我们再来尝试直接使用docker run myip -i就可以成功了。 这是因为当存在 ENTRYPOINT 后，CMD 的内容将会作为参数传给 ENTRYPOINT，而这里 -i 就是新的 CMD，因此会作为参数传给 curl，从而达到了我们预期的效果。 场景2：应用运行前的准备工作启动容器就是启动主进程，但有些时候，启动主进程前，需要一些准备工作。 比如 mysql 类的数据库，可能需要一些数据库配置、初始化的工作，这些工作要在最终的 mysql 服务器运行之前解决。 此外，可能希望避免使用 root 用户去启动服务，从而提高安全性，而在启动服务前还需要以 root 身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其它命令依旧可以使用 root 身份执行，方便调试等。 这些准备工作是和容器CMD无关的，无论CMD是什么，都需要事先进行一个预处理的工作。这种情况下，可以写一个脚本，然后放入ENTRYPOINT中去执行，而这个脚本会将接到的参数（也就是 &lt;CMD&gt;）作为命令，在脚本最后执行。比如官方镜像 redis 中就是这么做的： 12345678FROM alpine:3.4...RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis...ENTRYPOINT [&quot;docker-entrypoint.sh&quot;]EXPOSE 6379CMD [ &quot;redis-server&quot; ] 可以看到其中为了 redis 服务创建了 redis 用户，并在最后指定了ENTRYPOINT为docker-entrypoint.sh脚本： 1234567891011# 该脚本的内容就是根据CMD的内容来判断，如果是 redis-server 的话，则切换到 redis 用户身份启动服务器，否则依旧使用 root 身份执行#!/bin/sh...# allow the container to be started with `--user`if [ &quot;$1&quot; = &#x27;redis-server&#x27; -a &quot;$(id -u)&quot; = &#x27;0&#x27; ]; then chown -R redis . exec su-exec redis &quot;$0&quot; &quot;$@&quot;fiexec &quot;$@&quot; HEALTHCHECK 健康检查格式： 12HEALTHCHECK [options] CMD &lt;command&gt; #设置检查容器健康状况的命令HEALTHCHECK NONE #如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令 HEALTHCHECK 指令是告诉 Docker 应该如何进行判断容器的状态是否正常，这是 Docker 1.12 引入的新指令。 在没有 HEALTHCHECK 指令前，Docker 引擎只可以通过容器内主进程是否退出来判断容器是否状态异常。很多情况下这没问题，但是如果程序进入死锁状态，或者死循环状态，应用进程并不退出，但是该容器已经无法提供服务了。在 1.12 以前，Docker 不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务了却还在接受用户请求。 而自 1.12 之后，Docker 提供了 HEALTHCHECK 指令，通过该指令指定一行命令，用这行命令来判断容器主进程的服务状态是否还正常，从而比较真实的反应容器实际状态。 当在一个镜像指定了 HEALTHCHECK 指令后，用其启动容器，初始状态会为 starting，在 HEALTHCHECK 指令检查成功后变为 healthy，如果连续一定次数失败，则会变为 unhealthy。 HEALTHCHECK 支持下列选项： 123--interval=&lt;间隔&gt;：两次健康检查的间隔，默认为 30 秒；--timeout=&lt;时长&gt;：健康检查命令运行超时时间，如果超过这个时间，本次健康检查就被视为失败，默认 30 秒；--retries=&lt;次数&gt;：当连续失败指定次数后，则将容器状态视为 unhealthy，默认 3 次。 和 CMD, ENTRYPOINT 一样，HEALTHCHECK 只可以出现一次，如果写了多个，只有最后一个生效。 在HEALTHCHECK [options] CMD后面的命令，格式和 ENTRYPOINT 一样，分为 shell 格式，和 exec 格式。命令的返回值决定了该次健康检查的成功与否：0：成功；1：失败；2：保留，不要使用这个值。 假设我们有个镜像是个最简单的 Web 服务，我们希望增加健康检查来判断其 Web 服务是否在正常工作，我们可以用 curl 来帮助判断，其 Dockerfile 的 HEALTHCHECK 可以这么写： 123456# 这里我们设置了每5秒检查一次（这里为了试验所以间隔非常短，实际应该相对较长），如果健康检查命令超过3秒没响应就视为失败，并且使用 curl -fs http://localhost/ || exit 1 作为健康检查命令。FROM nginxRUN apt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf /var/lib/apt/lists/*HEALTHCHECK --interval=5s --timeout=3s \\ CMD curl -fs http://localhost/ || exit 1 为了帮助排障，健康检查命令的输出（包括 stdout 以及 stderr）都会被存储于健康状态里，可以用 docker inspect 来查看： 1docker inspect web | jq .[].State.Health ONBUILD 为他人作嫁衣裳格式： 1ONBUILD [INSTRUTION] ONBUILD 是一个特殊的指令，它后面跟的是其它指令，比如 RUN, COPY 等，而这些指令，在当前镜像构建时并不会被执行。只有当以当前镜像为基础镜像，去构建下一级镜像的时候才会被执行。 Dockerfile 中的其它指令都是为了定制当前镜像而准备的，唯有 ONBUILD 是为了帮助别人定制自己而准备的。 假设我们要制作 Node.js 所写的应用的镜像。我们都知道 Node.js 使用 npm 进行包管理，所有依赖、配置、启动信息等会放到 package.json 文件里。在拿到程序代码后，需要先进行 npm install 才可以获得所有需要的依赖。然后就可以通过 npm start 来启动应用。因此，一般来说会这样写 Dockerfile： 1234567FROM node:slimRUN mkdir /appWORKDIR /appCOPY ./package.json /appRUN [ &quot;npm&quot;, &quot;install&quot; ]COPY . /app/CMD [ &quot;npm&quot;, &quot;start&quot; ] 把这个 Dockerfile 放到 Node.js 项目的根目录，构建好镜像后，就可以直接拿来启动容器运行。但是如果我们还有第二个 Node.js 项目也差不多呢？好吧，那就再把这个 Dockerfile 复制到第二个项目里。那如果有第三个项目呢？再复制么？文件的副本越多，版本控制就越困难，让我们继续看这样的场景维护的问题。 如果第一个 Node.js 项目在开发过程中，发现这个 Dockerfile 里存在问题，比如敲错字了、或者需要安装额外的包，然后开发人员修复了这个 Dockerfile，再次构建，问题解决。第一个项目没问题了，但是第二个项目呢？虽然最初 Dockerfile 是复制、粘贴自第一个项目的，但是并不会因为第一个项目修复了他们的 Dockerfile，而第二个项目的 Dockerfile 就会被自动修复。 那么我们可不可以做一个基础镜像，然后各个项目使用这个基础镜像呢？这样基础镜像更新，各个项目不用同步 Dockerfile 的变化，重新构建后就继承了基础镜像的更新？好吧，可以，让我们看看这样的结果。那么上面的这个 Dockerfile 就会变为： 1234FROM node:slimRUN mkdir /appWORKDIR /appCMD [ &quot;npm&quot;, &quot;start&quot; ] 这里我们把项目相关的构建指令拿出来，放到子项目里去。假设这个基础镜像的名字为 my-node 的话，各个项目内的自己的 Dockerfile 就变为： 1234FROM my-nodeCOPY ./package.json /appRUN [ &quot;npm&quot;, &quot;install&quot; ]COPY . /app/ 基础镜像变化后，各个项目都用这个 Dockerfile 重新构建镜像，会继承基础镜像的更新。 那么，问题解决了么？其实也只解决了一半。如果这个 Dockerfile 里面有些东西需要调整呢？比如所有项目的npm install 都需要加一些参数，那怎么办？我们又不能直接把这一行RUN直接放到基础镜像里去，因为涉及到了当前项目的 ./package.json，难道又要一个个修改么？所以说，这样制作基础镜像，只解决了原来的 Dockerfile 的前4条指令的变化问题，而后面三条指令的变化则完全没办法处理。 ONBUILD 可以解决这个问题。让我们用 ONBUILD 重新写一下基础镜像的 Dockerfile: 1234567FROM node:slimRUN mkdir /appWORKDIR /appONBUILD COPY ./package.json /appONBUILD RUN [ &quot;npm&quot;, &quot;install&quot; ]ONBUILD COPY . /app/CMD [ &quot;npm&quot;, &quot;start&quot; ] 这次我们回到原始的 Dockerfile，但是这次将项目相关的指令加上 ONBUILD，这样在构建基础镜像的时候，这三行并不会被执行。然后各个项目的 Dockerfile 就变成了简单地： 1FROM my-node 是的，只有这么一行。当在各个项目目录中，用这个只有一行的 Dockerfile 构建镜像时，之前基础镜像的那三行 ONBUILD 就会开始执行，成功的将当前项目的代码复制进镜像、并且针对本项目执行 npm install，生成应用镜像。 使用Dockerfile构建镜像12# mysoft/centos:6.6为新生成的镜像的标签，&quot;.&quot;为dockerfile所在路径。docker build -t mysoft/centos:6.6 . 镜像构建上下文（Context）在上使用docker build来构建镜像的时候，在命令的最后面加了个”.”，我们直接解释为当前目录，即dockerfile所在的目录。其实这种表述是并不准确的。事实上这是在指定上下文路径。那么什么是上下文呢？ 首先我们要理解docker build的工作原理。Docker在运行时分为Docker引擎（也就是服务端守护进程）和客户端工具。Docker引擎提供了一组REST API，被称为Docker Remote API。而docker命令这样的客户端工具，则是通过这组api与docker引擎交互，从而完成这种功能。因此，虽然表面上我们好像是在本机执行各种docker功能，但实际上，一切都是使用的远程调用形式在服务端（Docker引擎）完成。也因为这种C/S设计，让我们操作远程服务器的Docker引擎变得轻而易举。 当我们进行镜像构建的时候，并非所有的定制都会通过RUN指令完成，经常会需要将一些本地文件复制进镜像，比如通过COPY、ADD等指令。而docker build 命令构建镜像，其实并非在本地，而是在服务端，也就是Docker引擎中构建的。那么在这种C/S架构中，如何 才能让服务端获得本地文件呢？ 这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，docker build命令得知这个路径后，会将路径下的所有内容打包，然后上传给Docker引擎。这样Docker引擎收到这个上下文包后，展开就会获得构建镜像所需的所有文件。 如果在Dockerfile中这么写： 1COPY ./package.json /app/ 这并不是要复制执行docker build命令所在的目录下的package.json，也是不复制Dockerfile所在目录下的package.json，而是复制上下文目录中的package.json。 因此，COPY这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么COPY ../packeg.json /app或者COPY /opt/xxx /app/这种指令无法工作的原因，因为这些路径已经超出了上下文的范围，Docker引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。 现在就可以理解docker build -t mysoft/centos:6.6 .中的这个”.”，实际是在指定上下文的目录，docker build命令会将该目录下的内容打包交给docker引擎以帮助构建镜像。 如果观察docker build 命令输出，其实可以看到发送上下文的过程： 123# docker build -t mysoft/centos:6.6 .Sending build context to Docker Daemon 2.512kB... 理解构建上下文对镜像构建是很重要的，可以避免犯一些不应该的错误。比如有些初学者在发现COPY /opt/xxx /app/不工作后，干脆将Dockerfile放到了根目录去构建。结果发现docker build执行后，在发送一个几十GB的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让docker build打包整个硬盘，这显然错误的使用方法。 一般来说，应该会将Dockerfile置于一个空目录下，如果该目录下没有所需的文件，那么应该把所需的文件复制一份过来。如果目录下有些东西确实不希望构建时传递给Docker引擎，那么可以使用和.gitignore一样的语法写一个.dockerignore，该文件是用于剔除不需要作为上下文传递给Docker引擎的文件。 那么为什么会有人误以为”.”是指定Dockerfile所在目录的呢？ 这是因为在默认情况下，如果不额外指定Dockerfile的话，会将上下文目录下的名为Dockerfile的文件作为Dockerfile。这只是默认行为，实际上Dockerfile的文件名并不要求必须为Dockerfile，并且并不要求必须位于上下文目录中，比如可以使用-f ../Dockerfile.py参数指定某个文件为Dockerfile。当然一般大家习惯性的会使用默认的文件名Dockerfile，以及会将其置于镜像构建上下文目录中。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"Docker","slug":"Docker","permalink":"http://example.com/tags/Docker/"}]},{"title":"信创UOS部分题目与注解","slug":"信创UOS部分题目与注解","date":"2023-06-16T07:16:09.000Z","updated":"2023-06-16T07:19:49.968Z","comments":true,"path":"2023/06/16/信创UOS部分题目与注解/","link":"","permalink":"http://example.com/2023/06/16/%E4%BF%A1%E5%88%9BUOS%E9%83%A8%E5%88%86%E9%A2%98%E7%9B%AE%E4%B8%8E%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"基本操作：（以httpd服务为例） 设置服务开机自启动 systemctl enable --now httpd 启动/重启/关闭服务 systemctl start/restart/stop httpd 更改主机名 hostnamectl set-hostname server1.example.com vim编辑器 一、 防火墙放行端口123456http 80 tcp…dhcp 8899 tcp#比赛将会给以上信息，要求放行这些端口/服务 allow：允许通过指定端口的网络流量。 deny：拒绝通过指定端口的网络流量。 reject：拒绝通过指定端口的网络流量，并发送错误响应包给客户端。 使用示例：# 格式：ufw allow/deny 端口/协议 开启或关闭ufw 1ufw enable/disable 开放端口 1ufw allow &lt;port&gt;/&lt;protocol&gt; 例如，允许TCP协议的80端口通过ufw： 1ufw allow 80/tcp 禁用端口 1ufw deny &lt;port&gt;/&lt;protocol&gt; 二、ssh免密对server1和server2配置免密，使俩台机器可以互相免密登录 1234ssh-key-gen -t rsa # 生成密钥ssh-copy-id root@server1 # 将密钥发送给server2# 在主控server1将生成的密钥发送给server2，server2即可免密登录server1# 题目要求互相免密登陆，所以要在server1和server2上都操作，将密钥生成后发送给对方 三、网络配置配置apt源并使之生效 123456vim /etc/apt/source.list# 这是apt源配置文件，在此配置源# 建议原有的不要删除，注释掉即可，在后面新增新的源deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverseapt update # 配置完更新软件清单 注：免密、网络、端口配置失败，后面题目将做不出来 四、配置虚拟主机 基于端口 基于域名 基于IP 12345678910111213141516171819apt install apache2 -y# 安装apache2， -y是指安装过程省略yes确认systemctl start apache2# 启动apache2systemctl enable apache2# 设置开机自启apt install ufw# 安装防火墙ufw enable# 设置开机自启ufw allow 80# 放行端口或 ufw allow ssh[root@UOS /var/www]# mkdir html_1 [root@UOS /var/www]# mkdir html_2 [root@UOS /var/www]# mkdir html_3 # 创建网站目录以及网站首页[root@UOS /var/www]# echo &quot;this is no.1&quot; &gt; ./html_2/index.html [root@UOS /var/www]# echo &quot;this is no.2&quot; &gt; ./html_2/index.html [root@UOS /var/www]# echo &quot;this is no.3&quot; &gt; ./html_3/index.html 基于端口的虚拟主机修改 /etc/apache2/sites-available/000-default.conf默认配置 若 /etc/apache2/sites-enabled/ vhosts.conf 配置了，则不使用默认配置 这是网页配置文件，决定网页在哪里 1234&lt;VirtualHost *:8080&gt; # ServerName 192.168.22.138 DocumentRoot /var/www/heml_1 &lt;/VirtualHost&gt; 修改/etc/apache目录下的ports.conf文件，在Listen 80下面加上一条Listen 8080，监听8080端口 12345Listen 80 Listen 8080 systemctl restart apache2# 重启apache2服务打开192.168.22.138 验证 基于IP的虚拟主机添加网卡，配置另一个IP， nmtui 图形化配置 12345678910&lt;VirtualHost 192.168.22.138:8080&gt; DocumentRoot /var/www/heml_1&lt;/VirtualHost&gt; &lt;VirtualHost 192.168.22.140:8080&gt; DocumentRoot /var/www/heml_2 &lt;/VirtualHost&gt; &lt;VirtualHost 192.168.22.142:8080&gt; DocumentRoot /var/www/heml_3 &lt;/VirtualHost&gt; 123systemctl restart apache2# 重启apache2服务打开 192.168.22.138 和 192.168.22.140 验证 基于域名的虚拟主机123456789101112131415161718vim /etc/hosts# 配置域名映射192.168.22.138 www.uos1.com&lt;VirtualHost *:8080&gt; ServerName www.uos1.com DocumentRoot /var/www/heml_1&lt;/VirtualHost&gt; &lt;VirtualHost *:8080&gt; ServerName www.uos2.com DocumentRoot /var/www/heml_2 &lt;/VirtualHost&gt; &lt;VirtualHost *:8080&gt; ServerName www.uos3.com DocumentRoot /var/www/heml_3 &lt;/VirtualHost&gt; 三种方法一起使用 123456789101112131415&lt;VirtualHost 192.168.22.138:80&gt; # ServerName www.uos1.com DocumentRoot /var/www/html_1 &lt;/VirtualHost&gt; &lt;VirtualHost 192.168.22.140:80&gt; # ServerName www.uos2.com DocumentRoot /var/www/html_2&lt;/VirtualHost&gt;&lt;VirtualHost *:80&gt; ServerName www.uos3.com DocumentRoot /var/www/html_3 &lt;/VirtualHost&gt; 五、时钟同步123456apt install chronyvim /etc/chrony/chrony.conf# 添加 server server.lab.example.com# server 后面接上题目给的时间服务器，此处为举例，添加后设置重启、开机启动systemctl restart chronysystemctl enable chronyd 六、脚本编写编写一个shell脚本，要求找出1..200内能被6整除的数字，并除以2后输出 vim script.sh 12345678910#!/bin/bashfor i in &#123;1..200&#125;do if [ $(($i%6)) -eq 0 ] then result=$(($i/2)) echo $result fidone 12chmod +x script.sh #添加运行权限./script.sh#运行 七、Docker配置与应用此题要求拉取服务器仓库上一个镜像，所以掌握Docker基本操作即可 123456789101112131415161718192021222324252627镜像的基本操作命令docker search uos #docker镜像查询docker pull uosproject/uos#下载镜像docker images #查看镜像docker save uosproject/uos:latest -o uos.tar #导出uos镜像为uos.tardocker load -i nginx.tar #导入本地镜像docker rmi nginx #删除镜像镜像的导出和导入docker save uosproject/uos &gt; /tmp/uos.tar#将镜像导出为tar文件docker rmi uosproject/uosdocker load &lt; /tmp/uos.tar#删除原有的uos镜像，通过文件导入镜像docker images #列出所有镜像容器基本命令docker run -it uosproject/uos bash #以bash环境启动镜像docker ps -a #不加-a只显示运行状态的docker进程，每次都随机创建容器名和容器IDdocker stop 597b8cd3ca55 #通过容器ID关闭容器docker start 597b8cd3ca55 #启动容器docker restart 597b8cd3ca55#重启容器docker logs 597b8cd3ca55#通过容器ID来查询日志docker tag uosproject/uos:latest uosproject/txuos:v1 #启动容器修改镜像的名称和标签，默认标签为latestdocker inspect uosproject/uos#查看镜像的底层信息docker attach 597b8cd3ca55#连接到容器docker ps#查看容器docker exec -it 597b8cd3ca55 bashdocker top 597b8cd3ca55#查看容器进程列表 可以尝试搭建一个apache2容器或者nginx容器 八、数据库基本操作在server1上，建立三个mariadb用户dbuser1/dbuer2/dbuser3在server1上，建立三个数据库uosdb1,/uosdb2/uosdb3一一对应授权：dbuser1只可访问uosdb1dbuser2只可访问uosdb2dbuser3只可访问uosdb3 九、ansible配置下载ansible并配置，使server1可以管理server2 下载ansible配置ansible 123456789101112131415161718192021222324252627vim /etc/ansible/ansible.cfg#重要配置[defaults]inventory=/home/root/ansible/inventoryremote_user=roothost_key_checking=False[privilege_escalation]become=Truebecome_method=sudobecome_user=rootbecome_ask_pass=Falsevim /etc/ansible/inventory#配置被控端清单#定义单个主机server1server2#定义主机组#[]里是主机组名称，下面加上属于此组的主机[group1]server1[group2]server2#定义嵌套组,group2组是group1主机组的成员[group1:children]group2 比赛的时候好像只需要配置主机清单inventory 若不清楚模块具体用法，安装ansible后可通过ansible-doc systemd查看用法（以systemd模块为例） 十、自动化安装编写playbook，在所有控制节点安装php和mariadb 看需求，若安装软件包则是第一个tasks，此处用了一个循环，可以下载多个安装包，比赛的时候是php和mariadb这两个。 若安装软件包组，则为第二个tasks，软件包组有空格，要加个@ 第三个tasks为更新所有软件包 - hosts 是指定任务运行的控制节点，all为所有，若只想在某个控制节点运行playbook，只需要写那个控制节点的主机名 123456789101112131415161718192021222324[root@controller ansible]$ vim package.yml# 在所有控制节点安装mariadb 和 php- name: Install package hosts: all become: true tasks: - name: Update apt cache apt: update_cache=yes# 使用Apt模块更新apt缓存。 - name: Install mariadb and php apt: name=&#123;&#123; item &#125;&#125; state=present with_items: - mariadb - php# 安装软件 - name: Enable service systemd: name: nginx.service enabled: yes state: started# 启动服务[admin@controller ansible]$ ansible-playbook packages.yml#掌握安装软件那步操作即可 十一、替换文件内容编写一个playbook，要求将被控段/var/www/html下的index.html文件替换成 this is file1 this is file2 123456789101112131415[admin@controller ansible]$ vim replace.yml- hosts: all tasks: - name: replace this is file1 replace: path: /var/www/html/index1.html regexp: &#x27;.*&#x27; replace: &#x27;this is file1&#x27; - name: replace this is file2 replace: path: /var/www/html/index2.html regexp: &#x27;.*&#x27; replace: &#x27;this is file2&#x27;[admin@controller ansible]$ ansible-playbook replace.yml 除以上知识外，比赛还将涉及到基础服务配置（nginx、DHCP、）、NFS、逻辑卷、vdo等","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"uos","slug":"UOS练习","date":"2023-05-27T13:57:11.000Z","updated":"2023-05-27T23:26:22.569Z","comments":true,"path":"2023/05/27/UOS练习/","link":"","permalink":"http://example.com/2023/05/27/UOS%E7%BB%83%E4%B9%A0/","excerpt":"","text":"基本知识重点服务运行维护技能服务的搭建、调优、维护掌握apache的各种解决方案12345678910111213141516171819apt install apache2 -y# 安装apache2systemctl start apache2# 启动apache2systemctl enable apache2# 设置开机自启apt install ufw# 安装防火墙ufw enable# 设置开机自启ufw allow 80# 放行端口或 ufw allow ssh[root@UOS /var/www]# mkdir html_1 [root@UOS /var/www]# mkdir html_2 [root@UOS /var/www]# mkdir html_3 # 创建网站目录以及网站首页[root@UOS /var/www]# echo &quot;this is no.1&quot; &gt; ./html_2/index.html [root@UOS /var/www]# echo &quot;this is no.2&quot; &gt; ./html_2/index.html [root@UOS /var/www]# echo &quot;this is no.3&quot; &gt; ./html_3/index.html 基于端口的虚拟主机修改 /etc/apache2/sites-available/000-default.conf默认配置 若 /etc/apache2/sites-enabled/ vhosts.conf 配置了，则不使用默认配置 这是网页配置文件，决定网页在哪里 1234&lt;VirtualHost *:8080&gt; # ServerName 192.168.22.138 DocumentRoot /var/www/heml_1 &lt;/VirtualHost&gt; 修改/etc/apache目录下的ports.conf文件，在Listen 80下面加上一条Listen 8080，监听8080端口 12345Listen 80 Listen 8080 systemctl restart apache2# 重启apache2服务打开192.168.22.138 验证 基于IP的虚拟主机添加网卡，配置另一个IP， nmtui 图形化配置 12345678910&lt;VirtualHost 192.168.22.138:8080&gt; DocumentRoot /var/www/heml_1&lt;/VirtualHost&gt; &lt;VirtualHost 192.168.22.140:8080&gt; DocumentRoot /var/www/heml_2 &lt;/VirtualHost&gt; &lt;VirtualHost 192.168.22.142:8080&gt; DocumentRoot /var/www/heml_3 &lt;/VirtualHost&gt; 123systemctl restart apache2# 重启apache2服务打开 192.168.22.138 和 192.168.22.140 验证 基于域名的虚拟主机123456789101112131415161718vim /etc/hosts# 配置域名映射192.168.22.138 www.uos1.com&lt;VirtualHost *:8080&gt; ServerName www.uos1.com DocumentRoot /var/www/heml_1&lt;/VirtualHost&gt; &lt;VirtualHost *:8080&gt; ServerName www.uos2.com DocumentRoot /var/www/heml_2 &lt;/VirtualHost&gt; &lt;VirtualHost *:8080&gt; ServerName www.uos3.com DocumentRoot /var/www/heml_3 &lt;/VirtualHost&gt; 三种方法一起使用 1234567891011121314&lt;VirtualHost 192.168.22.138:80&gt; # ServerName www.uos1.com DocumentRoot /var/www/html_1 &lt;/VirtualHost&gt; &lt;VirtualHost 192.168.22.140:80&gt; # ServerName www.uos2.com DocumentRoot /var/www/html_2&lt;/VirtualHost&gt;&lt;VirtualHost *:80&gt; ServerName www.uos3.com DocumentRoot /var/www/html_3 &lt;/VirtualHost&gt; 12345678修改httpd.conf文件，增加如下内容：Alias /bbs &quot;/forum/htdocs&quot; &lt;Directory &quot;/forum/htdocs&quot;&gt; Options Indexes FollowSymLinks MultiViews AllowOverride all Require all granted &lt;/Directory&gt; 上述别名的配置，就是说当你基于你的站点访问http://www.yourdoamin.com/bbs目录下的文件时，会直接从服务器/forum/htdocs目录下访问对应的文件。 LAMP12345678910111213141516[root@UOS /etc/apache2]# apt install -y php-mysql mariadb-server mariadb-client php-fpm libapache2-mod-php php-mysql # 安装环境[root@UOS /etc/apache2]# systemctl restart php7.3-fpm[root@UOS /etc/apache2]# systemctl enable php7.3-fpmSynchronizing state of php7.3-fpm.service with SysV service script with /lib/systemd/systemd-sysv-install.Executing: /lib/systemd/systemd-sysv-install enable php7.3-fpm[root@UOS /etc/apache2]# systemctl restart mariadb [root@UOS /etc/apache2]# systemctl enable mariadb#启动服务[root@UOS /etc/apache2]# echo &quot;&lt;?php phpinfo(); ?&quot; &gt;&gt; /var/www/html/index.php# 创建php测试页[root@UOS /etc/apache2]# systemctl restart apache2# 重启apache2[root@UOS /etc/apache2]# curl http://192.168.22.138/index.php # 客户端验证（F12查看php代码） 掌握多种网络存储：NFS、逻辑卷、vdo数据库MariaDB容器Docker批量系统管理ansible入侵检测及防护这里我们以查询系统登陆日志+使用ufw拒绝多次尝试登陆IP的方式，挡住黑客入侵的企图：首先，找出多次尝试登陆系统的IP: 1grep &quot;Failed password&quot; /var/log/auth.log | grep -Po &quot;from \\K\\d+\\\\. \\d+.\\d+.\\d+&quot; | uniq -c|tee 1 如果最次错误登陆次数大于10次，我们就把这个IP加入ufw的deny规则： 1cat 1 | awk &#x27;$1&gt;10&#123;print &quot;ufw deny &quot;$2&#125;&#x27; | sh 我们可以把这些命令规则加入到root的crontab里，周期性的检测和执行，这样就完成了一个简单的入侵检测策略。 找出所有连接过ssh22端口的所有IP,可以执行： 1grep -ri ufw /var/log/messages | grep DPT=22 | grep -Po &quot;.*SRC=\\K\\d+\\. \\d+. \\d+. \\d+&quot; 配置ssh免密登录常规 生成密钥对 使用以下命令，在本地系统上生成公钥和私钥对： 1ssh-keygen -t rsa 按照提示，设置密钥对文件名和选择一个口令。如果不想要口令的话，可以直接按 Enter 跳过。 将公钥复制到远程系统 使用以下命令将本地系统生成的公钥添加到远程系统的授权文件中： 1ssh-copy-id username@remote_host 其中，username 是远程系统的用户名，remote_host 是远程系统的 IP 地址或域名。执行命令后，会询问远程系统的密码。输入正确的密码，按回车键即可。 测试免密登录 使用以下命令测试免密登录是否成功： 1ssh username@remote_host 其中，username 和 remote_host 分别是远程系统的用户名和 IP 地址或域名。如果免密登录成功，则无需输入密码即可登录远程系统。 配置 SSH 服务 为了支持免密登录，需要在远程系统上配置 SSH 服务。首先，确保远程系统上存在 OpenSSH 服务： 1sudo apt-get install openssh-server 然后，编辑 SSH 服务配置文件 /etc/ssh/sshd_config： 1sudo nano /etc/ssh/sshd_config 找到以下两行，并将 # 去掉： 12RSAAuthentication yesPubkeyAuthentication yes 如果没有这两行，可以手动添加。编辑完毕后，保存并关闭文件。 接下来，重启 SSH 服务以应用配置修改： 1sudo systemctl restart ssh 以上就是在 Linux 操作系统上配置 SSH 免密登录的详细流程。 自动化1、准备虚拟机4台虚拟机：(ansible 192.168.200.10)(node1 192.168.200.11)(node2 192.168.200.12)(node3 192.168.200.13)2、配置免密登陆和hosts解析ssh-keygen 一直回车 #生成密钥ssh-copy-id node1 #拷贝私钥所有机器都必须是免密登陆4台主机上面配置/etc/hosts,以ansible主机为例 12345vim /etc/hosts192.168.200.10 ansible192.168.200.11 node1192.168.200.12 node2192.168.200.13 node3 Copy到每台主机： 1for i in &#123;10..13);do scp /etc/hosts 192.168.200.$i:/etc/hosts;done 3、安装ansible 1apt install -y ansible 4、配置主机清单 123456vim /etc/ansible/hosts[web]node1node2[db]node3 5、结果测试 1ansible all -m ping 简单项目通过模块批量完成主机的功能实现环境说明：一台物理机：pserver192.168.1.254三台虚拟机：server1 192.168.1.10server2 192.168.1.20server3 192.168.1.30要求：配置ssh:从物理机可以root免密登陆三台虚拟机；配置ansible主机列表，serverl在db组，server2和server3在web组；配置四台服务器的hosts文件，加入四台主机名和IP:使用ping模块测试四台主机的连通性；使用apt模块在db组安装mariadb-server;使用shel1模块获得web组服务器的mac地址； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768---- name: configure servers hosts: all become: yes tasks: - name: set up ssh key for root user authorized_key: user: root state: present key: &quot;&#123;&#123; lookup(&#x27;file&#x27;, &#x27;~/.ssh/id_rsa.pub&#x27;) &#125;&#125;&quot; - name: configure ansible inventory lineinfile: path: /etc/ansible/hosts line: &quot;&#123;&#123; item &#125;&#125;&quot; with_items: - &quot;[db]&quot; - &quot;server1 ansible_host=192.168.1.10&quot; - &quot;&quot; - &quot;[web]&quot; - &quot;server2 ansible_host=192.168.1.20&quot; - &quot;server3 ansible_host=192.168.1.30&quot; - &quot;&quot; - &quot;[all:vars]&quot; - &quot;ansible_python_interpreter=/usr/bin/python3&quot; - name: configure hosts file lineinfile: path: /etc/hosts line: &quot;&#123;&#123; item &#125;&#125;&quot; with_items: - &quot;192.168.1.254 pserver&quot; - &quot;192.168.1.10 server1&quot; - &quot;192.168.1.20 server2&quot; - &quot;192.168.1.30 server3&quot;- name: test connectivity hosts: all become: yes tasks: - name: ping hosts ping:- name: install mariadb-server hosts: db become: yes tasks: - name: install mariadb-server apt: name: mariadb-server state: present- name: get web servers&#x27; MAC addresses hosts: web become: yes tasks: - name: get MAC addresses shell: &quot;cat /sys/class/net/*/address&quot; register: result - name: show MAC addresses debug: var: result.stdout_lines 该 playbook 的任务如下： set up ssh key for root user: 将物理机的 ~/.ssh/id_rsa.pub 文件中的公钥添加到三台虚拟机的 /root/.ssh/authorized_keys 文件中，使 root 用户可以免密码登录。 configure ansible inventory: 在控制节点上配置 Ansible 的 inventory 文件，将 server1 加入 db 组，将 server2 和 server3 加入 web 组，并设置所有主机的解释器为 Python3。 configure hosts file: 配置四台服务器的 hosts 文件，加入四台主机名和 IP。 ping hosts: 使用 ping 模块测试四台主机的连通性。 install mariadb-server: 使用 apt 模块在 db 组安装 MariaDB。 get web servers&#39; MAC addresses: 使用 shell 模块获取 web 组服务器的 MAC 地址，并将输出保存到变量 result 中。 show MAC addresses: 使用 debug 模块显示变量 result 中的内容，即 web 组服务器的 MAC 地址。 编写剧本，根据企业环境部署web服务并进行优化环境说明：一台物理机：pserver192.168.1.254三台虚拟机：server1 192.168.1.10server2 192.168.1.20server3 192.168.1.30要求：配置ssh:从物理机可以root免密登陆三台虚拟机；配置ansible主机列表，serverl在db组，server2和server3在web组；配置四台服务器的hosts文件，加入四台主机名和IP;编写web.yaml,在web组服务器中安装apache2;在db组中安装mariadb-server;并启动安装的服务，检测服务的可用性； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081---- name: deploy web service hosts: web become: yes tasks: - name: set up ssh key for root user authorized_key: user: root state: present key: &quot;&#123;&#123; lookup(&#x27;file&#x27;, &#x27;~/.ssh/id_rsa.pub&#x27;) &#125;&#125;&quot; - name: configure ansible inventory lineinfile: path: /etc/ansible/hosts line: &quot;&#123;&#123; item &#125;&#125;&quot; with_items: - &quot;[db]&quot; - &quot;server1 ansible_host=192.168.1.10&quot; - &quot;&quot; - &quot;[web]&quot; - &quot;server2 ansible_host=192.168.1.20&quot; - &quot;server3 ansible_host=192.168.1.30&quot; - name: configure hosts file lineinfile: path: /etc/hosts line: &quot;&#123;&#123; item &#125;&#125;&quot; with_items: - &quot;192.168.1.254 pserver&quot; - &quot;192.168.1.10 server1&quot; - &quot;192.168.1.20 server2&quot; - &quot;192.168.1.30 server3&quot; - name: install apache2 apt: name: apache2 state: present - name: start apache2 service service: name: apache2 state: started - name: check apache2 status uri: url: http://&#123;&#123; inventory_hostname &#125;&#125; return_content: yes register: result failed_when: result.status not in [200, 301, 302] changed_when: false - name: debug debug: var: result- name: deploy database service hosts: db become: yes tasks: - name: set up ssh key for root user authorized_key: user: root state: present key: &quot;&#123;&#123; lookup(&#x27;file&#x27;, &#x27;~/.ssh/id_rsa.pub&#x27;) &#125;&#125;&quot; - name: install mariadb-server apt: name: mariadb-server state: present - name: start mariadb-server service service: name: mariadb state: started - name: check mariadb-server status shell: &quot;systemctl is-active --quiet mariadb&quot; changed_when: false 该 playbook 的任务如下： set up ssh key for root user: 将物理机的 ~/.ssh/id_rsa.pub 文件中的公钥添加到三台虚拟机的 /root/.ssh/authorized_keys 文件中，使 root 用户可以免密码登录。 configure ansible inventory: 在控制节点上配置 Ansible 的 inventory 文件，将 server1 加入 db 组，将 server2 和 server3 加入 web 组。 configure hosts file: 配置四台服务器的 hosts 文件，加入四台主机名和 IP。 install apache2: 使用 apt 模块安装 Apache2。 start apache2 service: 使用 service 模块启动 Apache2 服务。 check apache2 status: 使用 uri 模块检测 Apache2 服务的可用性，并将输出保存到变量 result 中。 debug: 使用 debug 模块显示变量 result 中的内容，即检测 Apache2 服务的结果。 install mariadb-server: 使用 apt 模块安装 MariaDB。 start mariadb-server service: 使用 service 模块启动 MariaDB 服务。 check mariadb-server status: 使用 shell 模块检查 MariaDB 服务是否正在运行。 编写剧本，完成嵌套循环，添加多用户环境说明：一台物理机：pserver192.168.1.254三台虚拟机：server1 192.168.1.10server2 192.168.1.20server3 192.168.1.30要求：配置ssh:从物理机可以root免密登陆三台虚拟机；配置ansible主机列表，server1在db组，server2和server3在web组；配置四台服务器的hosts文件，加入四台主机名和IP;编写useradd.yaml,使用循环，在所有虚拟机添加uos[1-3]三个用户 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849---- name: add users hosts: all become: yes tasks: - name: set up ssh key for root user authorized_key: user: root state: present key: &quot;&#123;&#123; lookup(&#x27;file&#x27;, &#x27;~/.ssh/id_rsa.pub&#x27;) &#125;&#125;&quot; - name: configure ansible inventory lineinfile: path: /etc/ansible/hosts line: &quot;&#123;&#123; item &#125;&#125;&quot; with_items: - &quot;[db]&quot; - &quot;server1 ansible_host=192.168.1.10&quot; - &quot;&quot; - &quot;[web]&quot; - &quot;server2 ansible_host=192.168.1.20&quot; - &quot;server3 ansible_host=192.168.1.30&quot; - name: configure hosts file lineinfile: path: /etc/hosts line: &quot;&#123;&#123; item &#125;&#125;&quot; with_items: - &quot;192.168.1.254 pserver&quot; - &quot;192.168.1.10 server1&quot; - &quot;192.168.1.20 server2&quot; - &quot;192.168.1.30 server3&quot; - name: add users user: name: &quot;uos&#123;&#123; item &#125;&#125;&quot; state: present loop: &quot;&#123;&#123; range(1,4)|list &#125;&#125;&quot; - name: display users shell: &quot;cut -d: -f1 /etc/passwd | grep -E &#x27;^uos[1-3]$&#x27;&quot; register: users changed_when: false - name: debug debug: var: users.stdout_lines set up ssh key for root user: 将物理机的 ~/.ssh/id_rsa.pub 文件中的公钥添加到三台虚拟机的 /root/.ssh/authorized_keys 文件中，使 root 用户可以免密码登录。 configure ansible inventory: 在控制节点上配置 Ansible 的 inventory 文件，将 server1 加入 db 组，将 server2 和 server3 加入 web 组。 configure hosts file: 配置四台服务器的 hosts 文件，加入四台主机名和 IP。 add users: 使用 user 模块循环添加 uos1、uos2 和 uos3 三个用户到所有虚拟机中。 display users: 使用 shell 模块执行命令，在所有虚拟机上获取当前用户列表，并将输出保存到变量 users 中。 debug: 使用 debug 模块显示变量 users 中的内容，即所有虚拟机中存在的 uos1、uos2 和 uos3 三个用户。 编写剧本，完成debug检测环境说明：一台物理机：pserver192.168.1.254三台虚拟机：server1 192.168.1.10server2 192.168.1.20server3 192.168.1.30要求：配置ssh:从物理机可以root免密登陆三台虚拟机；配置ansible主机列表，serverl在db组，server2和server3在web组；配置四台服务器的hosts文件，加入四台主机名和IP;编写mac.yaml,取得所有虚拟机mac地址(192.168.1.XX所在网卡)使用debug var获得命令输出 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647---- name: debug check hosts: all become: yes tasks: - name: set up ssh key for root user authorized_key: user: root state: present key: &quot;&#123;&#123; lookup(&#x27;file&#x27;, &#x27;~/.ssh/id_rsa.pub&#x27;) &#125;&#125;&quot; - name: configure ansible inventory lineinfile: path: /etc/ansible/hosts line: &quot;&#123;&#123; item &#125;&#125;&quot; with_items: - &quot;[db]&quot; - &quot;server1 ansible_host=192.168.1.10&quot; - &quot;&quot; - &quot;[web]&quot; - &quot;server2 ansible_host=192.168.1.20&quot; - &quot;server3 ansible_host=192.168.1.30&quot; - name: configure hosts file lineinfile: path: /etc/hosts line: &quot;&#123;&#123; item &#125;&#125;&quot; with_items: - &quot;192.168.1.254 pserver&quot; - &quot;192.168.1.10 server1&quot; - &quot;192.168.1.20 server2&quot; - &quot;192.168.1.30 server3&quot; - name: get MAC addresses of virtual machines command: &quot;ifconfig eth0 | grep &#x27;HWaddr&#x27; | awk &#x27;&#123;print $NF&#125;&#x27;&quot; register: mac_addresses ignore_errors: yes when: &quot;&#x27;192.168.1&#x27; in inventory_hostname&quot; changed_when: false failed_when: false - name: display MAC addresses debug: var: mac_addresses.stdout_lines when: &quot;&#x27;192.168.1&#x27; in inventory_hostname&quot; 该 playbook 的任务如下： set up ssh key for root user: 将物理机的 ~/.ssh/id_rsa.pub 文件中的公钥添加到三台虚拟机的 /root/.ssh/authorized_keys 文件中，使 root 用户可以免密码登录。 configure ansible inventory: 在控制节点上配置 Ansible 的 inventory 文件，将 server1 加入 db 组，将 server2 和 server3 加入 web 组。 configure hosts file: 配置四台服务器的 hosts 文件，加入四台主机名和 IP。 get MAC addresses of virtual machines: 在虚拟机上执行命令，获取其 eth0 网卡的 MAC 地址。使用 register 参数将输出保存到变量 mac_addresses 中，忽略脚本执行过程中的错误。 display MAC addresses: 使用 debug 模块显示变量 mac_addresses 中的内容（即 MAC 地址），仅在运行任务的主机属于 192.168.1.x 网段时执行。 综合项目1. 快速自动化安装配置DHCP服务器脚本 123456789101112131415161718192021222324252627282930313233---- name: install and configure dhcp server hosts: all become: yes tasks: - name: install dhcp server shell: sh /dhcp_install.sh #替换为实际脚本路径 register: dhcp_install_result - name: configure dhcp server block: - name: set dhcp listening interface lineinfile: path: /etc/default/isc-dhcp-server regexp: &#x27;^INTERFACESv4=&#x27; line: &#x27;INTERFACESv4=&quot;eth0&quot;&#x27; #替换为实际接口名称 - name: set dhcp network settings copy: dest: /etc/dhcp/dhcpd.conf content: | option domain-name &quot;example.com&quot;; option domain-name-servers 114.114.114.114; default-lease-time 3600; max-lease-time 7200; authoritative; subnet 192.168.1.0 netmask 255.255.255.0 &#123; range 192.168.1.100 192.168.1.200; option routers 192.168.1.254; &#125; when: dhcp_install_result.rc == 0 dhcp_install.sh 1234567891011121314#!/bin/bash# 安装 isc-dhcp-server 应用apt-get update &amp;&amp; apt-get install -y isc-dhcp-server# 创建备份文件cp /etc/default/isc-dhcp-server /etc/default/isc-dhcp-server.bak# 配置监听接口sed -i &#x27;s/#INTERFACESv4=&quot;&quot;/INTERFACESv4=&quot;eth0&quot;/&#x27; /etc/default/isc-dhcp-server# 重启 dhcp 服务systemctl restart isc-dhcp-server.service 上述 playbook 中，包含一个名为 install and configure dhcp server 的 play，该 play 会在所有目标主机上执行安装和配置 DHCP 服务器的任务。 playbook 中的任务分为两个部分：第一个任务用于安装 DHCP 服务器，使用 shell 模块调用指定的 shell 脚本来完成安装。任务使用 register 关键字，将安装结果保存在变量 dhcp_install_result 中。 第二个任务则用于对已安装的 DHCP 服务器进行配置，其中 block 关键字包含多个子任务。首先使用 lineinfile 模块修改服务器监听接口，使用 copy 模块复制配置文件模板，并修改其中的分配网段、IP范围、网关、掩码和 DNS 等参数。当且仅当安装任务成功后，才执行配置任务。 注意：请替换 playbook 中的脚本路径和接口名称为实际的值。另外，由于 DHCP 服务需要在特权模式下运行，所以需要将 playbook 中指定的 become 属性设置为“是”。 2.检查密码，如果用户三次输入密码均错误，则退出脚本要求：编写shell脚本，分别从键盘读入用户输入的用户名和密码：判断用户名为uos,密码为uos_123,不正确则重新输入；直到3次机会都用完，仍不正确则执行退出exit ll;正确则显示welcome要求2:使用shell模块，使此脚本在server1上运行； 123456789101112131415161718192021222324#!/bin/bashchance=3while [ $chance -gt 0 ]; do read -p &quot;请输入用户名: &quot; username read -s -p &quot;请输入密码: &quot; password # -s 参数用于隐藏输入内容 if [ &quot;$username&quot; = &quot;uos&quot; ] &amp;&amp; [ &quot;$password&quot; = &quot;uos_123&quot; ]; then echo -e &quot;\\nWelcome!&quot; exit 0 else echo -e &quot;\\n用户名或密码错误，请重试。&quot; let chance-=1 if [ $chance -gt 0 ]; then echo &quot;还有 $chance 次机会。&quot; fi fidoneecho &quot;错误次数已达上限，退出.&quot;exit 1# shell模块执行ansible server1 -m shell -a &#x27;/path/to/login.sh&#x27;","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"RHCE第一周作业","slug":"RHCE第一周作业","date":"2023-02-20T06:24:53.000Z","updated":"2023-02-20T06:27:52.098Z","comments":true,"path":"2023/02/20/RHCE第一周作业/","link":"","permalink":"http://example.com/2023/02/20/RHCE%E7%AC%AC%E4%B8%80%E5%91%A8%E4%BD%9C%E4%B8%9A/","excerpt":"","text":"1.创建一个用户user2，用root身份给user1修改密码为redhat。提示：创建用户用useradd 2.切换到user1用户，给自己修改一个密码，密码任意。 3.在/root/目录中创建一个以自己的汉语拼音为名字的文件，例如zhangsan.txt。并写入名字、年龄、出生日期、性别，每一项占一行，保存并退出。 4. 查找系统中所有与passwd关键词相关的man 帮助章节。 5.分别写出man帮助的第1,5,8章节是做什么的？1=Executable programs or shell commands 5=File formats and conventions eg /etc/passwd 8=System administration commands (usually only for root) 6.创建一个目录/data提示创建目录的命令为mkdir 7.使用浏览器打开RHEL8的web控制台，并用root登录 8.使用date将系统时间改为2023年10月01日晚上八点五十分18秒，时间使用24小时制 9.将系统时间改正准确后，以2023-02-19 00:00:00这样的格式输出 10.查看系统的历史命令 11.运行最近一条包含d开头的命令 12.清空/tmp目录 提示：删除使用rm 清空目录参考help帮助 13.查看user1家目录下面的所有文件包含隐藏文件","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"实现一次pip安装所有环境","slug":"实现一次pip安装所有环境","date":"2022-08-17T04:49:41.000Z","updated":"2022-08-17T04:51:13.116Z","comments":true,"path":"2022/08/17/实现一次pip安装所有环境/","link":"","permalink":"http://example.com/2022/08/17/%E5%AE%9E%E7%8E%B0%E4%B8%80%E6%AC%A1pip%E5%AE%89%E8%A3%85%E6%89%80%E6%9C%89%E7%8E%AF%E5%A2%83/","excerpt":"","text":"实现一次pip安装所有环境导出本地所安装的所有包pip list 只是在终端窗口列出所安装的所有包 pip freeze &gt;requirements.txt 将所有的包列入requirements.txt中。 安装所有包： pip install -r requirements.txt","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"Shell编程","slug":"Shell编程","date":"2022-06-04T14:22:14.000Z","updated":"2022-06-04T14:23:29.154Z","comments":true,"path":"2022/06/04/Shell编程/","link":"","permalink":"http://example.com/2022/06/04/Shell%E7%BC%96%E7%A8%8B/","excerpt":"","text":"编写shell脚本Shell脚本命令的工作方式有两种：交互式和批处理。 交互式（Interactive）：用户每输入一条命令就立即执行。 批处理（Batch）：由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。 一、编写简单的脚本SHELL脚本编写： 声明：#!/bin/bash（用来告诉系统使用哪种Shell解释器来执行该脚本） 注释： #xxxxxx（是对脚本功能和某些命令的介绍信息，使得自己或他人在日后看到这个脚本内容时，可以快速知道该脚本的作用或一些警告信息） 命令：xxxxxx 例1：查看当前所在工作路径并列出当前目录下所有的文件及属性信息： 注：Shell脚本文件的名称可以任意，但为了避免被误以为是普通文件，建议将.sh后缀加上，以表示是一个脚本文件。 执行上述脚本： 执行方式： 1、bash解释器命令直接运行Shell脚本文件； 2、通过输入完整路径的方式来执行。但默认会因为权限不足而提示报错信息，此时只需要为脚本文件增加执行权限即可。 二、接收用户的参数上述脚本程序只能执行一些预先定义好的功能，为了让Shell脚本程序更好地满足用户的一些实时需求，以便灵活完成工作，必须要让脚本程序能够像之前执行命令时那样，接收用户输入的参数。 当用户执行某一个命令，加或不加参数的输出结果是不同的。就是说，命令不仅要能接收用户输入的内容，还要有能力进行判断区别，根据不同的输入调用不同的功能。 Linux系统中的Shell脚本语言已经内设了用于接收参数的变量，变量之间使用空格间隔。 例如： $0指当前Shell脚本程序的名称； $#：指总共有几个参数； $*：指所有位置的参数值； $?：指显示上一次命令的执行返回值； $1、$2、$3……则分别对应着第N个位置的参数值，如下图所示： 效果如下： 三、判断用户的参数Shell脚本中的条件测试语法可以判断表达式是否成立，若条件成立则返回数字0，否则便返回非零值。 注：条件表达式两边均应有一个空格。 按照测试对象来划分，条件测试语句可以分为4种： 文件测试语句； 逻辑测试语句； 整数值比较语句； 字符串比较语句。 1、文件测试：即使用指定条件来判断文件是否存在或权限是否满足等情况的运算符，具体的参数如下表： ​ 文件测试所用的参数 操作符 作用 -d 测试文件是否为目录类型 -e 测试文件是否存在 -f 判断是否为一般文件 -r 测试当前用户是否有权限读取 -w 测试当前用户是否有权限写入 -x 测试当前用户是否有权限执行 例1：判断/etc/fstab是否为一个目录类型的文件，通过Shell解释器的内设$?变量显示上一条命令执行后的返回值。返回值为0，则目录存在。 2、逻辑测试语句：对测试结果进行逻辑分析； &amp;&amp;：逻辑“与”，表示当前面的命令执行成功后才会执行它后面的命令； ||：逻辑“或”，表示当前面的命令执行失败后才会执行它后面的命令； ！：逻辑“非”，表示把条件测试中的判断结果取相反值。如果原本测试的结果是正确的，则将其变成错误的；原本测试错误的结果则将其变成正确的。 例：判断/dev/cdrom文件是否存在，若存在则输出Exist字样。 例：结合系统环境变量USER来判断当前登录的用户是否为非管理员身份。 注：叹号应该加到判断语句的前面，代表对整个的测试语句进行取反值操作，不应该写成“$USER != root”，因为!=代表的是不等于符号≠。 3、整数值比较语句：不能将数字与字符串、文件等内容一起操作，可用的整数比较运算符如下表所示： 操作符 作用 -eq 是否等于 -ne 是否不等于 -gt 是否大于 -lt 是否小于 -le 是否等于或小于 -ge 是否大于或等于 例：使用free -m命令查看内存使用量情况（单位为MB），然后通过grep Mem:命令过滤出剩余内存量的行，再用awk ‘{print $4}’命令只保留第四列： 注：字母无法与数字进行大小比较，例如，“a是否大于等于3”是完全错误的，无法比较大小。 4、字符串比较语句：用于判断测试字符串是否为空值，或两个字符串是否相同。经常用来判断某个变量是否未被定义（即内容为空值）。 常见的字符串比较运算符： 操作符 作用 = 比较字符串内容是否相同 != 比较字符串内容是否不同 -z 判断字符串内容是否为空 例：通过判断String变量是否为空值，进而判断是否定义了这个变量： 例：结合逻辑运算符，当用于保存当前语系的环境变量值LANG不是英语（en.US）时，则会满足逻辑测试条件并输出“Not en.US”（非英语）的字样： 四、流程控制语句1、if条件测试语句：分为单分支结构、双分支结构、多分支结构； 例：单分支的if条件语句来判断/media/cdrom目录是否存在，若不存在就创建这个目录，反之则结束条件判断和整个Shell脚本。 例：使用双分支的if条件语句来验证某台主机是否在线：通过-c参数来规定尝试的次数，并使用-i参数定义每个数据包的发送间隔，以及使用-W参数定义等待超时时间。 注：**/dev/null 黑洞文件**，把输出信息重定向到这个文件等同于删除数据（类似于没有回收功能的垃圾箱），可以让用户的屏幕窗口保持简洁。 例：使用多分支的if条件语句来判断用户输入的分数在哪个成绩区间内。 read是用来读取用户输入信息的命令，能够把接收到的用户输入信息赋值给后面的指定变量，-p参数用于给予用户一些提示信息。 2、for条件循环语句 例：使用for循环语句从列表文件中读取多个用户名，然后为其逐一创建用户账户并设置密码。首先创建用户名称的列表文件users.txt，每个用户名称单独一行。 例：让脚本从主机列表文件ipaddrs.txt中自动读取IP地址，通过判断ping命令执行后的返回值来逐个测试主机是否在线。 3、while条件循环语句 例：编写一个用来猜测数值大小的脚本。该脚本使用**$RANDOM变量来调取出一个随机的数值（范围为0～32767），将这个随机数对1000进行取余操作，并使用expr命令**取得其结果，再用这个数值与用户通过read命令输入的数值进行比较判断。 while条件循环语句中的条件测试始终为true，因此判断语句会无限执行下去，直到用户输入的数值等于expr命令取得的数值后，这两者相等之后才运行exit 0命令，终止脚本的执行。 4、case条件测试语句 例：在脚本中组合使用case条件测试语句和通配符，提示用户输入一个字符并将其赋值给变量KEY，然后根据变量KEY的值向用户显示其值是字母、数字还是其他字符。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"Linux进程管理：任务计划服务程序","slug":"Linux进程管理：任务计划服务程序","date":"2022-05-21T11:36:14.000Z","updated":"2022-06-04T14:19:15.564Z","comments":true,"path":"2022/05/21/Linux进程管理：任务计划服务程序/","link":"","permalink":"http://example.com/2022/05/21/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%EF%BC%9A%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"Linux进程管理：任务计划服务程序计划任务分为一次性计划任务与长期性计划任务。 1、一次性计划任务：只执行一次，一般用于临时的工作需求。设置执行时间：at 时间 查看已设置好但还未执行的任务：at -l 删除任务：atrm 任务序号 at命令的参数及其作用 参数 作用 -f 指定包含命令的任务文件 -q 指定新任务名称 -l 显示待执行任务列表 -d 删除指定待执行任务 -m 任务执行后给用户发邮件 在使用at命令来设置一次性计划任务时，默认采用的是交互式方法。 例：设置20:30分自动重启，查看设置后的任务，然后删除任务。 注：warning提醒表示at命令只是在告诉我们接下来的任务将由sh解释器负责执行。 例：可以把前面学习的管道符（任意门）放到两条命令之间，让at命令接收前面echo命令的输出信息，以达到通过非交互式的方式创建计划一次性任务的目的。 如：echo “reboot” | at 20:30 例：把计划任务写入到Shell脚本中，当用户激活后再开始倒计时执行，可以使用“at now +2 MINUTE”的方式操作，这样代表2分钟（MINUTE）后执行这个任务，也可以替代成小时（HOUR）、日（DAY）、月（MONTH）等词汇： at now +2 MINUTE 时间的表示方法： 绝对表示方法： midnight //当天午夜 noon //当天中午 teatime //当天下午4点 hh:mm mm/dd/yy ​ 相对表示方法： now+n minutes //从现在起向后n分钟 now+n days //从现在起向后n天 now+n hours //从现在起向后n小时 now+n weeks //从现在起向后n周 2、长期性计划任务：周期性地、有规律地执行某些具体的任务。创建、编辑计划任务：crontab -e 查看当前计划任务：crontab -l 删除某条计划任务：crontab -r 以管理员的身份登录，可以在编辑他人的计划任务：crontab -u crontab命令的参数及其作用如下所示。 ​ crontab命令的参数及其作用 参数 作用 -e 编辑计划任务 -u 指定用户名称 -l 列出任务列表 -r 删除计划任务 使用crond服务设置任务的参数格式：分、时、日、月、星期 命令 注：如果有些字段没有被设置，则需要使用星号（*）占位。 使用crond设置任务的参数字段说明 字段 说明 分钟 取值为0～59的整数 小时 取值为0～23的任意整数 日期 取值为1～31的任意整数 月份 取值为1～12的任意整数 星期 取值为0～7的任意整数，其中0与7均为星期日 命令 要执行的命令或程序脚本 例：在每周一、三、五的凌晨3点25分，都需要使用tar命令把某个网站的数据目录进行打包处理，使其作为一个备份文件。 注： 用逗号“,”来分别表示多个时间段，例如“8,9,12”表示8月、9月和12月。 用减号“-”来表示一段连续的时间周期（例如字段“日”的取值为“12-15”，则表示每月的12～15日）。 用除号“/”表示执行任务的间隔时间（例如“*/2”表示每隔2分钟执行一次任务）。 在crond服务中需要同时包含多条计划任务的命令语句，应每行仅写一条。例如再添加一条计划任务，它的功能是每周一至周五的凌晨1点钟自动清空/tmp目录内的所有文件。 尤其需要注意的是，在crond服务的计划任务参数中，所有命令一定要用绝对路径的方式来写，如果不知道绝对路径，请用whereis命令进行查询，rm命令路径为下面输出信息中加粗部分。 删除定时任务： 还可以直接编辑配置文件达到设置定时任务的目的： vim /etc/crontab 缺点是直接编辑文件没有提示，使用crontab 命令若写错会有提示。 例子： 列出crontab 以root用户列出zhangsan 的crontab 1#crontab –u zhangsan –l 以普通用户zhangsan列出自己的crontab 1$crontab –l 对/var/spool/cron/zhangsan文件备份 12$crontab –l &gt;/home/zhangsan/zhangsancron $ls /home/zhangsan/zhangsancron 删除crontab 删除crontab也会删除/var/spool/cron目录中指定用户的文件 以用户root删除zhangsan的crontab文件 1#crontab –u zhangsan -r 以普通用户zhangsan删除自己的crontab文件 1$crontab -r 恢复丢失的crontab文件 如果不小心误删除了crontab文件，且在主目录下还有一个备份，那么可 以将其复制到/var/spool/cron/username（具体用户），如果由于权限问 题无法复制可以使用crontab命令解决 以zhangsan用户登录恢复丢失的crontab文件 1$crontab –r 删除文件 12$crontab –l $crontab /home/zhangsan/zhangsancron 恢复丢失的文件，恢复后可以看到文件信息 1$crontab –l","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"linux进程的前台/后台切换","slug":"Linux进程的前台-后台切换","date":"2022-05-19T07:52:12.000Z","updated":"2022-05-19T07:53:43.470Z","comments":true,"path":"2022/05/19/Linux进程的前台-后台切换/","link":"","permalink":"http://example.com/2022/05/19/Linux%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%89%8D%E5%8F%B0-%E5%90%8E%E5%8F%B0%E5%88%87%E6%8D%A2/","excerpt":"","text":"linux进程的前台/后台切换1. 把程序放到后台运行在前台运行的程序会一直占用终端命令行，例如你在前台解压的时候必须等着，期间干不了别的事（除非另开一个终端）。但是如果把进程放到后台，可以把终端空出来，你可以执行其它的操作。另一个好处是，放到后台的程序不会被ctrl+C（误触）给终止。 1.1 一开始就把进程放到后台运行直接在命令行末尾加上 &amp;： &lt;命令行&gt; &amp; 例如 python train.py &amp; 可以让train.py脚本一开始就在后台运行。这样运行后终端不会被占用，你仍然可以可以干别的事 1.2 把已经在前台运行进程放到后台如果命令已经在前台运行了，你想把它放到后台： 先键入Ctrl+z 选项把该进程暂停，放到后台（此时命令行空出来你可以干别的事）； 键入jobs -l查看进程的工作号（不是进程号PID），比如说工作号是2 键入 bg %2 即可把该进程放到后台运行（bg=background）。如果直接键入bg则是把所有进程放到后台。如果又想把后台程序放回前台，键入fg %2即可.（fg=foreground）如果直接想杀掉后台进程，键入kill %2，或kill &lt;PID号&gt;也可 但是，即使把程序放到后台运行，一旦关闭终端，或者远程终端断网，都会直接终止所有进程。对于一些需要长时间运行的程序，或者网络不稳定的情况下，我们希望在关闭终端下程序也照常运行，此时需要nohup命令： 使用nohup让程序后台不挂断地运行 该命令可以在你退出帐户/关闭终端之后继续运行相应的进程。关闭终端后，在另一个终端键入jobs已经无法看到后台的程序了，此时利用ps或top可以查看到。nohup常常配合后台标记 &amp;使用： nohup &lt;命令&gt; &amp; 例如nohup python train.py &amp; 可以让train.py脚本一开始就在后台运行，且不会因为关闭终端而被打断。该进程产生的所有输出都会到当前目录下的一个叫nohup.out的文件中。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"Linux用户与权限：权限管理","slug":"Linux用户与权限：权限管理","date":"2022-04-24T03:44:42.000Z","updated":"2022-04-24T03:47:27.922Z","comments":true,"path":"2022/04/24/Linux用户与权限：权限管理/","link":"","permalink":"http://example.com/2022/04/24/Linux%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90%EF%BC%9A%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86/","excerpt":"","text":"Linux用户与权限：权限管理概述Linux是多用户的操作系统，允许多个用户同时在系统上登录和工作。 为了确 保系统和用户的安全采取了如下安全管理方案： 通过UID/GID确定每个用户在登录系统后都做了些什么 通过UID/GID来区别不同用户所建立的文件或目录 每个文件或目录都属于一个UID和一个GID 每个进程都使用一个UID和一个或多个GID来运行 通常由被运行进程的用户决定 超级用户具有一切权限，无需特殊说明 普通用户只能不受限制的操作主目录及其子目录下的所有文件，对系统 中其他目录/文件的访问受到限制 分类文件所有者：user 文件所属组 ：group 其他用户 ：other 权限项 可读 可写 可执行 可读 可写 可执行 可读 可写 可执行 字符表示 r w x r w x r w x 数字表示 4 2 1 4 2 1 4 2 1 权限分配 user user user group group group other other other 目录上只有执行权限，表示可以进入或穿越他进入更深层次的子目录 目录上只有执行权限，要访问该目录下的有读权限的文件，必须知道文件名才可以访问 目录上只有执行权限，不能列出目录列表也不能删除该目录 目录上执行权限和读权限的组合，表示可以进入目录并列出目录列表 目录上执行权限和写权限的组合，表示可以在目录中创建、删除和重命名文件 分配三种基本权限 文件和目录的使用者 属主、同组人、其他人 权限分配 属主的权限：用于限制文件或目录的创建者 属组的权限：用于限制文件或目录所属组的成员 其他用户的权限：用于限制既不是属主又不是所属组的能访问该 文件或目录的其他人员 权限的优先顺序 如果UID匹配，就应用用户属主（user）权限 否则，如果GID匹配，就应用组（group）权限 如果都不匹配，就应用其它用户（other）权限 权限的管理 chmod改变文件或目录的权限 chown – 改变文件或目录的属主（所有者） chgrp – 改变文件或目录所属的组 umask – 设置文件的缺省生成掩码 su与sudo – 切换用户及权限下放 修改文件/目录的权限 更改已有文件或目录的访问权限 使用chmod命令 chmod命令有两种设置方法 文字设定法 使用字母和操作符表达式来修改或设定文件的访问权限 chmod [-R] &lt;文字模式&gt; &lt;文件或目录名&gt; 数值设定法 使用八进制数字来设定文件的访问权限 chmod [-R] &lt;八进制模式&gt; &lt;文件或目录名&gt; -R 选项表示对目录中的所有文件或子目录进行递归操作 chmod 的文字设定法chmod [操作对象] [+|-|=] [访问权限] 文件或目录名 操作对象 操作方法 访问权限 u 属主（user） + 添加某权限 r 读 g 同组（group） - 删除某权限 w 写 o 其他（others） = 直接赋予某权限并取消其 他所有权限 x 执行 a 所有（all） = 直接赋予某权限并取消其 他所有权限 - 无权限 举例： 123456789101112131415chmod u+rw myfile chmod a+rx,u+w myfilechmod u+rwx,g+rx,o+rx myfilechmod a+rwx ,g-w,o-w myfile chmod a=rwx myfile chmod go=rx myfile chmod u-wx,go-x myfile chmod a+x myfile 改变文件/目录属主或组 只有root用户才能改变文件的所有者 只有root用户或所有者才能改变文件所属的组 用 chown 命令改变属主 和/或 组 chown [-R] &lt;用户名[&lt;.|:&gt;组名]&gt; &lt;文件｜目录&gt; chgrp 被用来改变所属组 chgrp [-R] &lt;组名&gt; &lt;文件｜目录&gt; 举例： 12345678910111213chown soft myfilechgrp softgrp myfile chown .softgrp myfile chown -R soft mydir chgrp softgrp mydirchown -R :softgrp mydirchown -R soft.softgrp mydir umask命令 查看当前 umask 值 格式：umask [-S] 修改当前 umask 值 格式：umask u1u2u3 u1表示的是不允许属主有的权限 u2表示的是不允许同组人有的权限 u3表示的是不允许其他人有的权限 RHEL/CentOS默认的 umask 值 普通用户的 umask 是 002 root用户的 umask 是 022 umask值与文件/目录权限 umask值 新建目录的访问权限 新建文件的访问权限 022 777-022= 755 666-022= 644 027 777-027= 750 666-027= 640 002 777-002= 775 666-002= 664 006 777-006= 771 666-006= 660 007 777-007= 770 666-007= 660 su与sudo su可用于在不注销的情况下切换到系统中的另一个用户。可以让一个普通用户拥有超级用户或其他用户的权限，也可以让超级用户以普通用户 的身份做一些事情。普通用户使用这个命令时，必须有超级用户或者其他用户的密码口令，退出可使用exit。 sudo可以让用户以其他身份来执行指定的命令，默认的身份为root。在 /etc/sudoers中，设置了可执行sudo命令的用户。若其未经授权的用户企 图使用sudo，则会发出警告的邮件给管理员。用户使用sudo时，必须先 输入密码，之后有5分钟的有效期限，超过期限则需要重新输入密码。 Sudo提供日志，忠实的记录每个用户使用sudo做了什么，并能将日志传 到中心主机或者日志服务器。 通过sudo能把有些超级权限有针对性的下放，并且不需要用户知道root密 码，所以sudo相对于权限无限制性的su来说还是比较安全的，所以sudo 也能被称为受限制的su，另外sudo时需要授权许可的。 执行流程：当前用户切换到root并执行完后，直接退回到当前用户，前提 时要通过sudo的配置文件/etc/sudoers进行授权。 语法：sudo [选项] command 选项 含义 -b 在后台执行命令 -H 将HOME环境变量设为新身份的HOME环境变量 -k 结束密码的有效期限，下次在执行sudo时需要输入密码 -l 列出目前用户可执行与无法执行的命令，一般配置好 /etc/sudoers后，要用这个命令来查看和测试是否配置正确 -p 改变询问密码的提示符号 -s 执行指定的shell -u用户 以指定的用户作为新的身份，若不加上此参数，则默认以root 作为新的身份 -v 显示用户的时间戳，如果用户运行sudo，输入用户密码后，在 段时间内可以不用输入口令，就可以直接进行sudo操作，用-v 可以跟踪最新的时间戳。 特殊权限可执行文件的特殊权限 suid：使用命令的所属用户的权限来运行，而不是命令执行者的权 限 ，（对一个可执行文件，不是以发起者身份来获取资源，而是 以可执行文件的用户所有者身份来执行的）。 sgid：使用命令的组权限来运行目录的特殊权限，在设置了 sgid 权 限的目录中创建的文件会具备该目录的组权限。 sticky-bit：在带有粘滞位的目录中的文件只能被文件的所属用户 和root用户删除，不管该目录的写入权限是如何设置的 设置特殊权限 参数 作用 u+s 设置SUID权限 u-s 取消SUID权限 g+s 设置SGID权限 g-s 取消SGID权限 o+t 设置SBIT权限 o-t 取消SBIT权限 特殊权限的文字表示方法SUID和SGID用s表示；Sticky-bit用t表示 SUID是占用属主的x位置来表示 SGID是占用组的x位置来表示 sticky-bit是占用其他人的x位置来表示 例如 123456789-rwsr-xr-x 1 root root 23420 2019-08-11 /usr/bin/passwd -rwxr-sr-x 1 root tty 11084 03-10 21:28 /usr/bin/write -rwsr-sr-x 1 root root 315416 2019-01-06 /usr/bin/crontab drwxrws--- 3 root admin 4096 06-18 01:01 /admin/sales drwxrwxrwt 5 root root 4096 06-18 01:01 /tmp 特殊权限的数值表示方法 权限 对应数字 SUID 4 SGID 2 Sticky-bit 1 - 0 举例： 1234567891011-rwsr-xr-x ——4755-rwxr-sr-x ——2755-rwsr-sr-x ——6755drwxrws---——2770 drwxrwxrwt ——1777 -rwxr-xr-x ——0755 使用chmod设置特殊权限 为程序 ~/bin/myapp 添加 SUID权限 ```#chmod u+s ~/bin/myapp #chmod 4755 ~/bin/myapp123456789 - 为目录 /home/groupspace 添加 SGID权限 - ``` #chmod g+s /home/groupspace #chmod 2755 /home/groupspace 为目录 /home/share 添加 sticky-bit 权限 #chmod o+t /home/share #chmod 1755 /home/share 文件隐藏属性 chattr命令 chattr命令用于设置文件的隐藏权限，英文全称为change attributes，语法格式为“chattr [参数] 文件名称”。 lsattr命令 lsattr命令用于查看文件的隐藏权限，英文全称为“list attributes”，语法格式为“lsattr [参数] 文件名称”。 chattr命令中的参数及其作用 参数 作用 i 无法对文件进行修改；若对目录设置了该参数，则仅能修改其中的子文件内容而不能新建或删除文件 a 仅允许补充（追加）内容，无法覆盖/删除内容（Append Only） S 文件内容在变更后立即同步到硬盘（sync） s 彻底从硬盘中删除，不可恢复（用零块填充原文件所在的硬盘区域） A 不再修改这个文件或目录的最后访问时间（Atime） b 不再修改文件或目录的存取时间 D 检查压缩文件中的错误 d 使用dump命令备份时忽略本文件/目录 c 默认将文件或目录进行压缩 u 当删除该文件后依然保留其在硬盘中的数据，方便日后恢复 t 让文件系统支持尾部合并（tail-merging） x 可以直接访问压缩文件中的内容 文件访问控制列表 setfacl命令 setfacl命令用于管理文件的ACL权限规则，英文全称为“set files ACL”， 语法格式为“setfacl [参数] 文件名称”。 getfacl命令 getfacl命令用于查看文件的ACL权限规则，英文全称为“get files ACL”， 语法格式为“getfacl [参数] 文件名称”。 参数 作用 -m 修改权限 -M 从文件中读取权限 -x 删除某个权限 -b 删除全部权限 -R 递归子目录 这点不做重点要求，若有同学有意向考证，则需掌握","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"Linux用户与权限：用户与组管理","slug":"Linux用户与权限：用户与组管理","date":"2022-04-24T02:46:16.000Z","updated":"2022-04-24T03:48:28.779Z","comments":true,"path":"2022/04/24/Linux用户与权限：用户与组管理/","link":"","permalink":"http://example.com/2022/04/24/Linux%E7%94%A8%E6%88%B7%E4%B8%8E%E6%9D%83%E9%99%90%EF%BC%9A%E7%94%A8%E6%88%B7%E4%B8%8E%E7%BB%84%E7%AE%A1%E7%90%86/","excerpt":"","text":"Linux用户与权限：用户与组管理用户管理groups 查看当前登录用户的组内成员groups gliethttp 查看gliethttp用户所在的组,以及组内成员whoami 查看当前登录用户名 任何用户被分配一个独特的用户id号(UID)，当用户登录时，它被分配一个主目录并 且运行一个程序(通常是一个shell程序) 没有权限许可用户不能读取、写或者执行其它用户的文件 用户帐号通常从UID 500开始(员工辞职后若删除原ID也删除，再重新建立除非指定， 否则顺后面一位数字，例如503 每一个文件都属于一个UID和GID所有（每一个用户都有一个匹配的用户和组） 任何进程运行时都带一个UID和一个或多个GID标识符 通常决定于哪个用户执行这个进程 三种访问类别 运行的进程跟文件有着同样的UID（user) 运行的进程跟文件有着同样的GID(group) 其它进程(other） 1. 添加新用户 useradd/adduser 格式:useradd/adduser [选项] [用户名] 参数： 选项 含义 -u 指定用户的UID值 -g 指定用户所属的默认组 -G 指定用户附加组 -m 若用户主目录不存在则建立用户主目录 -d 指定主目录 -e 指定用户帐号有效日期(YYYY-MM-DD) -s 指定默认的shell类型 -M 不建立用户主目录 实例： 1234567891011121314#useradd u2#useradd -g g2 u2 #useradd -e 2019-01-12 u3#useradd -g group1 -e 12/12/2019 user1#passwd user1#useradd -G staff tom #passwd tom#useradd -G ftpgrp -d /var/ftp2 -s /sbin/nologin -M ftp1#passwd ftp1 2. 设置用户口令passwd 格式：passwd [选项] [用户名] passwd //设置密码、激活用户；//注：新建的帐号都为禁用状态； 注：root用户可以更改所在用户的密码，而普通的用户只能修改本身的密码； 选项 含义 -l 锁定帐号：即不能用该帐号登录 -u 解锁帐号； -d 删除帐号的密码，超级用户使用 -k 保持身份验证不过期 -e 终止指名账户的密码 -w 在密码过期前多少天提醒用户 -x/-n 密码的最长/最短有效时限 -f 强制执行操作 123456789#passwd –x 60 user 设置 user用户的密码有效期#passwd -w 10 user 设置 user 用户的密码失效前10天开始提醒用户 #passwd -l user 可以锁定用户 user #passwd -s user 显示用户user 当前已被锁定 #passwd -u user 解除user用户帐号的锁定 3. 批量用户管理批量创建用户帐号输入 # newusers &lt; new 批量新建用户帐号 格式– newusers &lt;filename&gt; -filename的格式与 /etc/passwd 一致 举例 1234567#vi userfile.txt#cat userfile.txt user1:\\x:1001:1001::/home/user1:/bin/bashuser2:x\\:1002:1002::/home/user2:/bin/bashftpuser1:\\x:2001:2001::/home/ftpuser1:/sbin/nologinftpuser2:\\x:2002:2002::/home/ftpuser2:/sbin/nologin #newusers userfile.txt 批量设置密码输入 # pwunconv 暂时取消shadow加密 #chpasswd &lt; newpasswd 批量设置用户密码 #pwconv 恢复用户密码 格式 – chpasswd &lt; &lt;filename\\&gt; -filename 每一行的格式： username:password username必须是系统上已存在的用户 举例 1234567#vi userpwdfile.txt; chmod 600 userpwdfile.txt#cat userpwdfile.txt user1:123456 user2:passwd ftpuser1:123qaz ftpuser2:xsw321 #chpasswd &lt; userpwdfile.txt 4.删除用户 格式： userdel [选项] [ 用户名] 选项： 选项 含义 -r 删除用户并同时删除用户主目录及本地邮件 存储文件等信息 -f 强制删除用户 实例： #userdel -r user1 注意：如果只是临时禁止用户登录系统，那么不用删除账户，可以采取 临时查封用户账号的办法。编辑口令文件/etc/passwd，将*放在要被查封 用户的加密口领域，这样该用户就不能登录系统了。但是主目录，文件 以及组信息还是保留的。如果以后需要修改，将*改为x 5.修改用户信息 格式： usermod [选项] [用户名] 选项： 选项 含义 -l 更改用户名 -d 更改用户主目录 G 修改附加组 -g 修改主组 -L 锁定用户帐号(不能登录) -U 解锁用户帐号 -c 改变用户的表述信息 -e 设置用户账户的过期时间 -s 改变用户的默认shell 实例： 123456#usermod -d /abc u3 usermod -G group2 u3 #usermod -l user3 u3#usermod -L user1 #usermod -U user1 组管理简介 用户指派给组 每一个组被分配一个独特的组ID(GID) GID保存在/etc/group中，加密后的密码存放在/etc/gshadow中 每一个用户都有自己的私有组 同一个组中的所有用户能共享属于这个组的文件 分类 分类法一： 标准组 标准组可以容纳多个用户 若使用标准组，在创建一个新的用户时就应该指定他所属于的组 私有组 私有组中只有用户自己 当在创建一个新用户时， 若没有指定他所属于的组，RHEL/CentOS 就建立一个和该用户同名的私有组，且用户被分配到这个私有组中 优点：防止新文件归 “公共” 组所有 缺点：可能会鼓励创建 “任何人都可以访问” 的文件 分类法二： 主要组群：当一个用户账户属于多个组群成员时，登录后所属的组群 便是主要组群，其他的组群是次要组群，一个用户账户只能属于一个 主要组群，即主组 次要组群：也称为附加组群，一个用户账户可以属于多个次要组群 组管理工具groupadd添加组格式 # groupadd [选项] [组群名] 选项 选项 含义 -g 为组群设置GID -r 创建系统组群 -o 允许使用和别的组群相同的GID创建组群 -f 即使组群已经存在，还是强制创建组群 -p (密码) 为新组群设置加密的密码 举例 12345#groupadd mygroup 创建组#groupadd -r sysgroup 创建系统组群 #groupadd -g 888 group2 创建指定GID组 groupdel删除组groupdel：删除一个已存在组，但不能删主组 需要从系统上删除组群时，可用groupdel命令来完成这项工作，如果该组群中仍包 括某些用户，则必须先使用userdel命令删除这些用户后，才能使用groupdel命令删 除组群。如果有任何一个组群的使用者在线上就不能移除该组群。 格式：# groupdel [组群名] 举例： 删除组群user1 123#groupdel user1 #cat /etc/group |grep user1 groupmod 修改组格式 #groupmod [选项][组群名] 选项 选项 含义 -g 设置组群 -o 重复使用组群GID -n(新组群名) 更改组群名称 举例 123#groupmod -g 503 mygroup#groupmod –n newgroup mygroup gpasswd设置组群密码格式： gpasswd [选项][组群名] 选项 含义 -a 将一个用户加入到一个组群中 -d 将一个用户从一个组群中删除 -r 取消一个组群的组群密码 -R 限制其成员访问组 -A(组群管理员) 指定组群的管理员 -M(用户) 设置组群的成员列表 举例： 123 #gpasswd –A pl mygroup //将pl设为mygroup群组的管理员 $gpasswd –a aaa mygroup //pl可以向mygroup群组添加用户aaa newgrp新组名 给组账号设置完密码后，用户登录系统，使用newgrp命令，输入给组 账号设置的密码，就可以临时添加到指定组，可以管理组用户，具有组权限。 使用newgrp命令可以让用户账户以另一个组群的身份进行登录，即用 相同的账户名、不同的组群身份登录系统。如果要切换，用户必须是 该组群的用户，否则无法登录指定的组群。单一用户如果要同时隶属 多个组群，需要利用交替用户的设置。如果不指定组群名称，则 newgrp命令会登录该用户名称的预设组群。 语法：newgrp [组群名] 举例： • 将用户pl以组群user的身份登录系统 • #su – pl • #id • #newgrp user • #id pl 用户和组的关系 组是用户的集合。 一个标准组可以容纳多个用户。 同一个用户可以同属于多个组，这些组可以是私有组，也可以是标准组。 当一个用户同属于多个组时，将这些组习惯分为 ： 主组（初始组）：用户登录系统时 的组。 附加组：可切换的其他组。 练习1、创建一个用户 test useradd test 2、创建一个用户test1 指定其主组为test useradd -g test test1 3、创建一个用户 test2 指定其uid 为1000 useradd -u 1000 test2 4、将test1、test2 加入到test组中 usermod -a -G test test1 usermod -a -G test test2 *5、添加一个用户 user3 uid 为600 设置其家目录在/data/user3 主组为 test 附加组为 test1 test2 需要创建data 目录 #mkdir /data useradd -u 600 -d /data/user3 -g test user3","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"Linux文件与目录管理：文本内容显示与处理","slug":"Linux文件与目录管理：文本内容显示与处理","date":"2022-04-23T04:35:24.000Z","updated":"2022-04-23T04:47:29.926Z","comments":true,"path":"2022/04/23/Linux文件与目录管理：文本内容显示与处理/","link":"","permalink":"http://example.com/2022/04/23/Linux%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%EF%BC%9A%E6%96%87%E6%9C%AC%E5%86%85%E5%AE%B9%E6%98%BE%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/","excerpt":"","text":"Linux文件与目录管理：文本内容显示与处理内容显示1. cat功能：使用cat命令可以显示文本文件的内容，也可以把几个文件内容附加到另一个 文件中。如果没有指定文件，或者文件为“.”，那么就从标准输入读取。 语法：cat [选项] [文件] 选项含义： 选项 含义 -n 对输出的所有行编号 -b 对非空输出行编号 -s 当遇到有连续两行以上的空白行时，就将其替换为一 行的空白行 -E 在每行结束处显示$ 2. head功能：使用head命令显示指定文件的前若干行 语法：head [选项] [文件] 选项含义： 选项 含义 -n 输出文件前n行，默认10行 -c 指定输出文件的大小 3. tail功能：使用tail命令显示指定文件的末尾若干行 语法：tail [选项] [文件] 选项含义： 选项 含义 -n 输出文件后n行，默认10行 -f filename 把filename最后内容显示在屏幕上 ，并不断刷新， 常用语日志文件的实时监控，ctrl+c结束命令 4. cut功能：使用cut从每行中显示出选定的字节、字符或字段（域） 语法：cut [选项] [文件] 选项含义： 选项 含义 -b 只选中指定的这些字节 -c 只选中指定的这些字符 -d 使用指定分界符代替制表符作为区域分解 -f 指定文件中设想被定界符（缺省情况下为制表符）隔开的字 段的列表 -n 取消分割多字节字符。 -s 不打印没有包含分界符的行 案例 1、 显示/etc/passwd文件中用户登录名和用户名全称字段，即第一个和第五个字段，由：隔开 #cut -f 1,5 –d : /etc/passwd #cat /etc/passwd |cut -d : -f 1,5 5. less功能：使用less从可以回卷显示文本文件的内容，允许往回卷动 语法：less [选项] [文件] 选项含义： 选项 含义 v 用文本编辑器打开该文件 n/N 跳转到next/previous匹配的地方 /test 搜索text -S 行过长时间将超出部分舍弃 -e 当文件显示结束后，自动离开 -i 忽略搜索时的大小写 -m 显示类似more命令的百分比 6. more功能：使用more分页显示文本文件 语法：more [选项] [文件] 选项含义： 选项 含义 -f 计算行数时，使用实际的行数，而不是自动换行过后的行数 -p 不以卷动的方式显示每一页，而是先清除屏幕后在显示内容 -c 跟-p选项类似，不同的是先显示内容再清除其他旧资料 -s 当遇到有连续两行以上的空白行时，就将其替换为一行的空 白行 -u 不显示下行号 +n 从第n行开始显示文件内容，n代表数字 -n 一次显示的行数，n代表数字 Less和more区别 less:一次查看一个页面的输入 该命名的用法和more相似，可以查看超过一屏的文件内容，不同的是，less 命令除了可以按空格键向下显示文件外，还可以利用方向键来滚动显示文件， 要结束浏览时只要在less的提示符”:”下按Q键即可。 $ls –l /etc | less more：该命令一般用于显示内容超过一屏的文件，为了避免文件内容显示瞬 间就消失，可以使用more命令让文件显示满一屏时就暂停，在按下任意键的 时候继续显示下一屏内容，例如，当ls命令查看文件列表时，若文件太多， 则可配合more命令来使用。如下所示 $ls - al /etc | more 7. grep功能：使用grep分页显示文本文件 语法：grep [选项] [查找模式] [文件] 选项含义： 选项 含义 -E 模式是一个可亏站的正则表达式 -i 比较时不区分大小写 -c 只显示匹配行的数量 -h 抑制输出的文件名前缀 -r 递归读取每个目录下的所有文件 -q 禁止一切正常输出 -s 取消错误信息 案例 1、在文件/etc/passwd中搜索匹配字符“zhangsan” #grep ‘zhangsan’ /etc/passwd 2、显示所有以d开头的文件中包含test 的行数据内容 1234567#cat d1 1 test #cat d2 2 test #grep ‘test’ d* 3、查找sshd进程信息 #ps –ef |grep sshd 4、显示d开头的文件中包含“aa”行数据内容 12345#cat file1 abababababababaa #cat file2 #aaaaaaaaa #grep‘aa’d* 5、在/root/aa文件中输出不是以b开头的行内容 #grep -v ^b /root/aa 内容处理1. sort功能：使用sort命令可以对文件中的数据进行排序，并将结果显示在标准输出上。 语法：sort [选项] [文件] 选项含义： 选项 含义 -m 如果给定文件已排好序，那么合并文件 -u 对排序后认为相同的行只留其中一行 -d 按字典顺序排序，比较时仅字母、数字、空格和制表 符有意义 -f 将小写字母与大写字母同等对待 -r 按逆序输出排列结果 -c 检查给定文件是否已排好序，如果没有，则打印一个 出错信息，并以状态值1退出 3. uniq功能：使用uniq命令可以将文件内的重复行数据从输出文件中删除，只留下每条记 录的唯一样本。 语法：uniq [选项] [文件] 选项含义： 选项 含义 -i 在比较的时候不区分大小写 -u 只显示文件中不重复的行 -s K 比较时跳过前K个字符，K是数字 -D 显示所有输出的行 -d 只输出重复的行 -c 显示输出中在每行行首加上本行在文件中出现的 次数 4. comm功能：使用comm逐行比较已排序过的文件，并将结果显示出来 语法：comm [选项] [文件1] [文件2] 选项含义： 选项 含义 -1 不输出文件1特有的行 -2 不输出文件2特有的行 -3 不输出文件3特有的行 案例 file1文件内存放ab abab，file2文件内存放ab aaab 1、比较文件file1和file2的文件内容 123#cat file1 #cat file2 #comm file1 file2 2、比较文件file1和file2，只显示文件file1和file2中相同行的数据内容 #comm -12 file1 file2 4. diff功能：使用diff逐行比较两个文本文件，列出不同之处 语法：diff [选项] [文件1] [文件2] 选项含义： 选项 含义 -b 忽略行尾的空格，而字符串中的一个或多个空格符都 视为相等 -c 使用上下文输出格式 -r 当比较目录时，递归比较任何找到的子目录 -y 以两列并排格式输出 -w 忽略所有的空白 -a 所有的文件都视为文本文件来逐行比较 -q 只比较简短的输出文件是否不同 -s 当两个文件相同时报告 案例 file1文件内存放abab aaaa，file2文件内存放aaaa 1、比较文件file1和file2的文件内容，列出其不同之处 123#cat file1 #cat file2 #diff file1 file2 5. echo功能：在显示器上显示一段文字，一般起到提示的作用 语法：echo [选项] [字符串或环境变量] 选项含义： 选项 含义 -n 表示输出文字后不换行，字符串可以加引号，表示将字符串 原样输出，也可以不加引号，表示将字符串中的各个单词作 为字符串输出，各字符串之间用一个空格分开 -e 出现特殊字符时，特殊处理 案例 file1文件内存放ab abab，file2文件内存放ab aaab 1、使用echo命令追加内容 12345#echo e1234 &gt;file1 #echo e4321 &gt;&gt;file1 #cat file1 #echo e1234 &gt;file1 #cat file1 2、echo hello 3、echo $HOME 6. join功能：将两个文件中指定栏位相同的行并加以合并，再输出 语法：join [-i] [-a1或2] [-e字符串] [-o格式] [-t字符] 选项含义： 选项 含义 -a 除了显示原来的输出内容之外，还显示指令文件中没有相同栏位的行。 -e 若[文件1]与[文件2]中找不到指定的栏位，则在输出中填入选项中的字符串。 -i 比较栏位内容时，忽略大小写的差异。 -o 按照指定的格式来显示结果。 -t 使用栏位的分隔字符。 -v 跟-a相同，但是只显示文件中没有相同栏位的行。 -1 连接[文件1]指定的栏位。 -2 连接[文件2]指定的栏位。 案例 显示file1和file2文件内容，并合并 1234#cat file1 #cat file2 #join file1 file2 #join file2 file1 Vim文本编辑器命令模式控制光标移动，可对文本进行复制、粘贴、删除和查找等工作。 命令 作用 dd 删除（剪切）光标所在整行 5dd 删除（剪切）从光标处开始的5行 yy 复制光标所在整行 5yy 复制从光标处开始的5行 n 显示搜索命令定位到的下一个字符串 N 显示搜索命令定位到的上一个字符串 u 撤销上一步的操作 p 将之前删除（dd）或复制（yy）过的数据粘贴到光标后面 输入模式正常的文本录入。 末行模式保存或退出文档，以及设置编辑环境。 命令 作用 :w 保存 :q 退出 :q! 强制退出（放弃对文档的修改内容） :wq! 强制保存退出 :set nu 显示行号 :set nonu 不显示行号 :命令 执行该命令 :整数 跳转到该行 :s/one/two 将当前光标所在行的第一个one替换成two :s/one/two/g 将当前光标所在行的所有one替换成two :%s/one/two/g 将全文中的所有one替换成two ?字符串 在文本中从下至上搜索该字符串 /字符串 在文本中从上至下搜索该字符串 三种切换命令模式 [a\\i\\o 等键] 输入模式 [Esc] 命令模式 命令模式 [:键] 末行模式 [Esc] 命令模式 命令相关命令行自动补全在Linux系统中，有太多的命令和文件名称需要记忆，使用命令行补全功能可以 快速地写出文件名和命令名。 按Tab键可以自动补全 案例 #ifco 按下Tab键可补全ifconfig命令 历史命令功能：在Linux系统中，每一个人操作的命令都会记录到命令历史中，在以后可以通过命令历史查看和使用以前操作的命令。 语法1： history history n 当history命令没有参数，将显示整个历史命令列表的内容，如果使 用n参数，将显示最后n个历史命令。 语法2： #history -a|n|r|w filename 把当前的历史命令记录追加到历史命令文件中。 选项 含义 -a 把当前的历史命令记录追加到历史命令文件中 -c 清空历史命令列表 -n 将历史文件中的内容加入到当前历史命令列表中 -r 将历史命令文件中的内容更新（替换）当前历史命令列表 -w 把当前历史命令列表的内容写入历史命令文件，并且覆盖 历史命令文件的原来内容 命令别名功能：命令别名是Bash Shell的强特性，在执行非常长的命令时，可以定制命令 格式：#alias 别名=“命令” 案例 1. 用户可以把常用的ps –uax|more定制为psa。 例: #alias psa=”ps -aux|more” 注意： 在定义别名时，等号两边不能有空格，等号右边的命令一般都会包含空格或 特殊字符，此时需要用引号 仅对本次登录系统有效，如果希望每次登录系统都能够使用该命令别名，可以编辑~/.bashrc文件（root用户是/root/.bashrc,普通用户是/home/*/.bashrc）","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"Linux文件与目录管理：压缩、重定向与管道","slug":"Linux文件与目录管理：压缩、重定向与管道","date":"2022-04-23T04:35:06.000Z","updated":"2022-04-23T04:47:29.926Z","comments":true,"path":"2022/04/23/Linux文件与目录管理：压缩、重定向与管道/","link":"","permalink":"http://example.com/2022/04/23/Linux%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%EF%BC%9A%E5%8E%8B%E7%BC%A9%E3%80%81%E9%87%8D%E5%AE%9A%E5%90%91%E4%B8%8E%E7%AE%A1%E9%81%93/","excerpt":"","text":"Linux文件与目录管理：压缩、重定向与管道归档文件和压缩文件 归档是把很多文件放到一个文件中，方便做备份、存储和传输 采用tar – 标准的linux归档命令 归档通常被压缩 算法应用到压缩文件上 解压恢复原始文件 tar 传统支持使用gzip和gunzip,或者bzip2和bunzip2的压缩方式 tar 基本功能：打包和解包 格式： tar [选项] 文件或者目录 常用选项 -c：创建新的打包文件。 -t：列出打包文件的内容，查看已经打包了哪些文件。 -x：从打包文件中释放文件。 -f：指定打包文件名。 -v：详细列出 tar 处理的文件信息。 -z：用 gzip 来压缩/解压缩打包文件。 -j：用 bzip2 来压缩/解压缩打包文件。 -r：追加新的文档 -U：追加 例： 1、归档/root/abc目录，生成文件为/root/abc.tar #tar –cvf /root/abc.tar /root/abc #ls –l /root/abc.tar 2、查看/root/abc.tar归档文件的内容 #tar –tvf /root/abc.tar 3、将归档文件/root/abc.tar解包出来 #tar –xvf /root/abc.tar 4、将文件/root/abc/d添加到/root/abc.tar归档文件中 #touch /root/abc/d #tar -rvf /root/abc.tar /root/abc/d #tar –tvf /root/abc.tar 5、更新归档文件/root/abc.tar中的文件/root/abc/d #tar –uvf /root/abc.tar /root/abc/d #tar –tvf /root/abc.tar 注意： “-f 文件名|设备名”是一个整体， 所以 -cvf myball.tar 不能写成：-cfv myball.tar 或 -fcv myball.tar gzip Linux下常用的压缩和解压缩命令。 由官方仓库的gzip软件包提供。 压缩后 gzip 会在每个文件的后面添加扩展名 .gz。 压缩后原文件会被自动删除。 在 windows 下可以用 winzip 或 winrar或7-zip 解压。 用法：gzip [选项] 文件列表 选项： -d: 解开压缩文件。 -f: 强行压缩文件，不理会文件名称或硬链接是否存在以及该文件是否为符号链接。 -l: 列出压缩文件的相关信息（压缩文件的大小；未压缩文件的大小；压缩比；未 压缩文件的名字）。 -n: 压缩文件时，不保存原来的文件名称及时间戳（默认为保存，即-N）。 -r : 递归处理，将指定目录下的所有文件及子目录一同处理。 -t : 测试压缩文件是否正确无误。 -v : 显示指令执行过程。 -&lt;压缩率&gt; : 压缩率是一个介于1～9的数值，默认值为“6”，数值越大压缩率越高。 -best 参数等价于-9；–fast参数等价于-1 例： Tar 调用gzip实例 1、将/root/abc目录压缩成/root/abc.tar.gz文件 #tar -zcvf /root/abc.tar.gz /root/abc 2、查看/root/abc.tar.gz文件 #tar -ztvf /root/abc.tar.gz 3、将压缩文件/root/abc.tar.gz解压出来 #tar -zxvf /root/abc.tar.gz 或者 压缩/root/abc.tar #gzip /root/abc.tar 解压/root/abc.tar .gz #gzip –d /root/abc.tar .gz bzip2 Linux下常用的压缩和解压缩命令。 由官方仓库的bzip2软件包提供。 比gzip的压缩比更高。 压缩后 bzip2 会在每个文件的后面添加扩展名 .bz2。 压缩后原文件会被自动删除。 在 windows 下可以用 winrar或7-zip 解压。 bzip2命令的格式和参数与gzip类似 例： 压缩文件filename $ bzip2 filename 高度压缩文件 file1和file2并显示执行过程 $ bzip2 -9v file1 file2 解压filename.bz2文件 $ bzip2 -d filename.bz2 $ bunzip2 filename.bz2 zip/unzip与windows下的 winzip兼容 由官方仓库的zip/unzip软件包提供 例如： – 压缩文件 file1为 fiel1.zip，原文件保留 $ zip file1.zip file1 – 将子目录 data1/ 下的所有文件压缩到文件 data1.zip $ zip –r data1.zip data1 – 解压释放压缩文件 data1.zip 中的所有文件 $ unzip data1.zip 显示压缩文件的内容不解压，显示压缩文件的内容： 1、zcat、zless 对于用gzip压缩的文件，zcat，zless命令可以在不解压的情况下，直接显示文件的内容 zcat：直接显示压缩文件的内容 zless：直接逐行显示压缩文件的内容 2、bzcat、bzless 对于bzip2压缩文件，bzcat，bzless命令可以在不解压的情况下，直接 显示文件的内容 bzcat：直接显示压缩文件的内容 Bzless：直接逐行显示压缩文件的内容 rar和7za rar – 由RPMForge仓库的rar软件包提供 7za – http://www.7-zip.org – http://p7zip.sourceforge.net/ – 由EPEL仓库的p7zip软件包提 重定向所谓重定向，就是不使用系统的标准输入端口、标准输出端口或标准错误端口，而进行重新的指定，所以重定向分为输出重定向、输入重定向和错误重定向。通常情况下重定向到一个文件。 在Shell中，要实现重定向主要依靠重定向符实现，即Shell是检查命令行中有无重定向符来决定是否需要实施重定向 输入输出重定向 名称 文件描述符 含义 设备 说明 STDIN 0 标准输入 键盘 命令在执行时所要的输入通过它来取得 STDOUT 1 标准输出 显示器 命令执行后的输出结果从该端口送出 STDERR 2 标准错误 显示器 命令执行时的错误信息通过该端口送出 输入重定向中用到的符号及其作用 符号 作用 命令 &lt; 文件 将文件作为命令的标准输入 命令 &lt;&lt; 分界符 从标准输入中读入，直到遇见分界符才停止 命令 &lt; 文件1 &gt; 文件2 将文件1作为命令的标准输入并将标准输出到文件2 输出重定向中用到的符号及其作用 符号 作用 命令 &gt; 文件 将标准输出重定向到一个文件中（清空原有文件的数据） 命令 2&gt; 文件 将错误输出重定向到一个文件中（清空原有文件的数据） 命令 &gt;&gt; 文件 将标准输出重定向到一个文件中（追加到原有内容的后面） 命令 2&gt;&gt; 文件 将错误输出重定向到一个文件中（追加到原有内容的后面） 命令 &gt;&gt; 文件2&gt;&amp;1或 命令 &amp;&gt;&gt; 文件 将标准输出与错误输出共同写入到文件中（追加到原有内容的后面） 例： $ ls -l /tmp &gt;mydir $ ls -l /etc &gt;&gt;mydir $ myprogram 2&gt; err_file $ myprogram &amp;&gt; output_and_err_file $ find ~ -name *.mp3 &gt; ~/cd.play.list $ echo “Please call me : 68800000”&gt;message $ cat &lt;&lt;!&gt;mytext This text forms the content of the heredocument , which continues until the end of text delimite Command &gt; file 将command的标准输出定向到 file Command &gt;&gt; file 将command的标准输出附加到 file Command &lt; file 将file作为输入发送到command Command 2&gt; file 将command的错误输出定向到 file Command 2&gt;&gt; file 将command的错误输出附加到 file Command &amp;&gt; file 将所有输出重定向到文件 管道管道的引入UNIX 系统的一个基本哲学是：一连串的小命令能够解决大问题。其中每个小命令都能够很好地完成一项单一的工作。现在需要有一些东 西能够将这些简单的命令连接起来，这样管道就应运而生。 许多Linux命令具有过滤特性，即一条命令通过标准输入端口接受一个 文件中的数据，命令执行后产生的结果数据又通过标准输出端口送给 后一条命令，作为该命令的输入数据。后一条命令也是通过标准输入 端口而接受输入数据。 管道（使用符号“|”表示）用来连接命令 命令1 | 命令2 将命令1的STDOUT发送给命令2的STDIN STDERR不能通过管道转发 用来组合多种工具的功能 命令1 | 命令2 | 命令3 |…… ls -C | tr &#39;a-z&#39; &#39;A-Z‘ | wc 管道线中的每一条命令都作为一个单独的进程运行，每一条命令的输出作为下一条命令的输入。 由于管道线中的命令总是从左到右顺序执行的，因此管道线是单向的。 注：不要误以为管道命令符只能在一个命令组合中使用一次。可以这样使用：“命令A | 命令B | 命令C”。 曾经有位东北的同学做了一个特别贴切的类比：把管道符当做流水线作业，这跟吃顿烧烤是同一个道理，即第一个人负责切肉，第二个人负责串肉，第三个人负责烧烤，最后的处理结果交付给用户。 特点1、任何写入到标准输出的命令都可以在管道的左侧使用。 2、任何从标准输入读取的命令都可以在管道的右侧使用。 3、可以用管道将多个命令连到一起， 例： 1、使用简单的管道 #ls /etc |more 2、使用复杂的通道 #rpm –qa |grep a |more 3、显示passwd文档中pl的用户信息，并统计有少字符/行 。 #cat /etc/passwd |grep ‘pl’ |wc –l 附加：通配符 通配符 含义 * 任意字符 ? 单个任意字符 [a-z] 单个小写字母 [A-Z] 单个大写字母 [a-Z] 单个字母 [0-9] 单个数字 [[:alpha:]] 任意字母 [[:upper:]] 任意大写字母 [[:lower:]] 任意小写字母 [[:digit:]] 所有数字 [[:alnum:]] 任意字母加数字 [[:punct:]] 标点符号 通配符不一定非要放到最后面，也可以放到前面。 可用于搜索文件或代替被通配的字符。 可以与创建文件的命令相结合，创建出好多个文件。 还可以输出一些指定的信息。","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"jdk的配置","slug":"jdk的配置","date":"2022-03-23T13:41:24.000Z","updated":"2022-03-23T14:00:25.673Z","comments":true,"path":"2022/03/23/jdk的配置/","link":"","permalink":"http://example.com/2022/03/23/jdk%E7%9A%84%E9%85%8D%E7%BD%AE/","excerpt":"","text":"现在开始配置环境变量，就以下四步搞定 1.右击我的电脑-属性-高级-环境变量，找到它后左击，在系统变量下点击新建 2.输入变量名输入JAVA_HOME,变量值即是你安装jdk的位置，我是C:\\Program Files\\Java\\jdk1.6.0_10 3.JAVA_HOME创建好后，我们开始创建PATH,变量值即使你电脑上bin文件的位置，还是在你安装java的文件夹中(CLASSPATH也是)，我是C:\\ProgramFiles\\Java\\jdk1.6.0_10\\bin 最后创建CLASSPATH,输入变量值，这里是找到tools.jar文件的位置，我是.;C:\\Program Files\\Java\\jdk1.6.0_11\\lib\\tools.jar;（注意在复制路径到里面后，别忘了在最前面加上”.;”为了方便记忆，说白了，就是在前面加一个点和一个分号）","categories":[],"tags":[{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"}]},{"title":"Linux文件与目录管理：文件与查找","slug":"Linux文件与目录管理：文件与查找","date":"2022-03-23T07:12:13.000Z","updated":"2022-05-31T09:21:40.452Z","comments":true,"path":"2022/03/23/Linux文件与目录管理：文件与查找/","link":"","permalink":"http://example.com/2022/03/23/Linux%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%EF%BC%9A%E6%96%87%E4%BB%B6%E4%B8%8E%E6%9F%A5%E6%89%BE/","excerpt":"","text":"Linux文件与目录管理：文件与查找处理特殊字符：假设系统中有一个文件叫“-abc” ，如果我们想对它进行操作，例如现在要删除它，方法分 别如下： 我们可以命令行中输入rm – -abc命令来删除文件。（若直接在命令行中输入rm -abc命令，则 无效，由于文件名的第一个字符为 - ，Linux把文件名当作选项了，所以我们要使用“–”符 号来解决这个问题），其它的特殊字符也一样 文件权限若有一个文件的类型与权限数据为“-rwxr-xr–” 先将整个类型与权限数据分开查阅，并将十个字符整理成为如下所示; 12[-][rwx][r-x][r--] 1 234 567 890 1为:代表这个文件名为目录(d)或文件，本例中为文件（-) ﹔ 234为:拥有者的权限，本例中为可读、可写、可执行（rwx） ; 567为:同群组使用者权限，本例中为可读可执行（rx） ;890为:其他使用者权限，本例中为可读(r），就是只读之意. 同时注意到，rwx所在的位置是不会改变的，有该权限就会显示字 chown用法：用来更改某个目录或文件的用户名和用户组。 chown 用户名:组名 文件路径（可以是绝对路径也可以是相对路径） 例1：chown root:root /tmp/tmp1 就是把tmp下的tmp1的用户名和用户组改成root和root（只修改了tmp1的属组）。 例2：chown -R root:root /tmp/tmp1 就是把tmp下的tmp1下的所有文件的属组都改成root和root。 chmod用法：用来修改某个目录或文件的访问权限。 语法：chmod [-cfvR] [--help] [--version] [who] [+ | - | =] [mode] 文件名 例子：chmod -R 777 /home/linux find查找#find 时间，类型，名字，大小，用户，组，权限 #locate updatedb手动更新数据库 • 功能：在文件系统中查找匹配的文件 • 格式 find [&lt;起始目录&gt; …] [&lt;选项表达式&gt;] [&lt;条件匹配表达式&gt;] [&lt;动作表达式&gt;] • 说明 – &lt;起始目录&gt;：对每个指定的 &lt;起始目录&gt; 递归搜索目录树 • 省略&lt;起始目录&gt;时表示当前目录 – &lt;选项表达式&gt;：控制 find 命令的行为 – &lt;条件匹配表达式&gt;：根据匹配条件查找文件 – &lt;动作表达式&gt;：指定对查找结果的操作，默认为显示在标准输出（-print） – 不带任何参数的 find 命令将在屏幕上递归显示当前目录下的文件列表。 文件的时间戳 • GNU/Linux 文件的3种类型的时间戳： – mtime: 最后修改时间 (ls -lt) – ctime: 状态改变时间 (ls -lc) – atime: 最后访问时间 (ls -lu) • 说明 – ctime并非文件创建时间。 – 覆盖一个文件会改变mtime、ctime和atime三类时间。 – 改变文件的访问权限或拥有者会改变文件的ctime和atime。 – 读文件会改变文件的atime。 选项 说明 -L 如果遇到符号链接文件，就跟踪链接所指的文件 -regextype TYPE 指定 -regex 和 -iregex 使用的正则表达式类型，默 认为 emacs -depth/-d 查找目录自身之前先处理目录中的文件（即深度 优先） -mount/-xdev 查找文件时不跨越文件系统 -maxdepth LEVELS 设置最大的查找深度 –help 显示 find 命令帮助信息 –version 显示 find 的版本 例： • 递归显示当前目录的文件列表 $ find • 递归显示 / 目录的文件列表 $ find / • 递归显示 / 目录的文件列表（仅限于3层目录） $ find / -maxdepth 3 • 递归显示 / 目录的文件列表（仅限于 / 文件系统） $ find / -xdev • 递归显示 /home、/www、/srv 目录的文件列表 $ find /home /www /srv 条件表达式–文件名 条件 说明 -name PATTERN 匹配文件名 -iname PATTERN 匹配文件名（忽略大小写） -lname PATTERN 匹配符号链接文件名 -ilname PATTERN 匹配符号链接文件名（忽略大小写） -wholename PATTERN 匹配文件的完整路径（不把 ‘/’ 和 ‘.’ 作为特殊字符） -iwholename PATTERN 匹配文件的完整路径（忽略大小写） PATTERN 使用 Shell 的匹配模式 • 可以使用 Shell 的通配符（*、？[]） • 要用“”或‘’括起来 条件表达式–时间属性 条件 说明 -amin N 查找 N 分钟以前被访问过的所有文件 -atime N 查找 N 天以前被访问过的所有文件 -cmin N 查找 N 分钟以前文件状态被修改过的所有文件（比如权限修改） -ctime N 查找 N 天以前文件状态被修改过的所有文件 （比如权限修改） -mmin N 查找 N 分钟以前文件内容被修改过的所有文件 -mtime N 查找 N 天以前文件内容被修改过的所有文件 -used N 查找被改动过之后，在N天内被存取过的所有文件 注：以上选项中的 N 可以有三种输入方式：N,+N,-N  +20 表示大于 20 （21，22，23 等）  -20 表示小于 20 （19，18，17 等） 20 表示等于 20 例： • 在/home下查找最近2天之内改动过的文件 $ find /home -mtime -2 • 在/home下查找最近2天之内被访问过的文件 $ find /home -atime -2 • 在/home下查找60分钟之前改动过的文件 $ find /home -mmin +60 条件 说明 -newer FILE 查找所有比 FILE 的内容修改时间新的文件 -cnewer FILE 查找所有比 FILE 的状态修改时间新的文件（比如权限修改） -anewer FILE 查找所有比 FILE 的访问时间新的文件 FILE 为要比对的样板文件或目录 例： • 在/home下查找更新时间比tmp.txt新的文件或目录 $ find /home -newer tmp.txt • 在/home下查找存取时间比tmp.txt新的文件或目录 $ find /home -anewer tmp.txt 条件表达式–用户和组 条件 说明 -uid N 用户ID为N的所有文件 -gid N 组ID为N的所有文件 -user USERNAME 用户名为 USERNAME 的所有文件 -group GROUPNAME 组名为 GROUPNAME 的所有文件 -nouser 文件属于不在 /etc/passwd 文件中的用户 -nogroup 文件属于不在 /etc/group 文件中的组 N 可以使用 N,+N,-N 例： • 查找在系统中已作废用户（在/etc/passwd中无记录）的文件 $ find / -nouser • 查找属于 osmond 用户的文件 $ find / -user osmond • 查找属于 students 组的文件 $ find / -group students • 查找UID为502的所有文件 $ find / -uid 502 • 查找UID大于600的所有文件 $ find / -uid +600 • 查找GID小于60的所有文件 $ find / -gid -60 条件表达式–文件权限 条件 说明 -perm MODE 精确匹配权限模式为 MODE 的文件 -perm MODE 匹配权限模式至少为 MODE 的文件 （用户、组和其他人这三种权限必须都匹配） -perm /MODE 或 -perm +MODE 匹配权限模式至少为 MODE 的文件 （用户、组和其他人这三种权限中有一种匹配即 可） MODE 与 chown 命令的书写方式一致，既可以使用字符模式也可以 使用八进制的数值模式，通常使用八进制的数值模式 例： • 在/home目录下查找权限为700的所有文件或目录 $ find /home -perm 700 • 在/home目录下查找权限至少为740的所有文件或目录 $ find /home -perm -740 条件表达式–类型和大小 条件 说明 -type TYPE 查找类型为 TYPE 的文件，可用的类型： b-块设备文件; c-字符设备文件; d-目录文件; p-命名管道; f-普通文件; l-符号链接; s-socket 文件 -links N 查找有N个链接的文件 -inum N 查找文件inode为N的文件 -samefile NAME 查找与NAME文件具有相同inode的文件 -size N[bcwkMG] 查找文件大小为N的文件，单位可以为： b-512 字节的块（省略单位的默认值）; c-字节; w-双字节; k-Kilobytes; M-Megabytes; G-Gigabytes -empty 查找空文件（大小为0） 例： • 在/home目录下查找硬连接数大于2的文件 $find /home -links +2 • 在当前目录下查找长度大于10kB的文件 $find . -size +10k • 在/tmp目录下查找长度等于1GB的文件 $find /tmp -size 1G • 在当前目录下查找长度小于10MB的文件 $find . -size -10M find 命令–动作表达式• -print ​ – 在标准输出上列出查找结果（每行一个文件） • -ls ​ – 使用 ‘ls -dils’ 在标准输出上列出查找结果 • -prune ​ – 忽略对某个目录的查找 • -exec COMMAND {} ; ​ – 对符合查找条件的文件执行 Linux 命令 • -ok COMMAND {} ; – 对符合查找条件的文件执行 Linux 命令；与 -exec 不同 的是，它会询问用户是否需要执行 • {} 两个大括号之间不能有空格，表示查找到的对象 • ; 表示命令结束，反斜杠与前面的大括号之间必须要留空格 例： • 查找并列出当前目录下不安全的文件（世界可读写执行） $ find . -perm -007 -ls • 查找 logs 目录下的所有的 .log 文件并查看它的详细信息 $ find logs -name &quot;*.log&quot; -type f -exec ls -l &#123;&#125; \\; • 查找当天修改过的普通文件并显示出来 $ find . -type f -mtime -1 -exec ls -l &#123;&#125; \\; • 在/data/目录下查找以.sh结尾的权限模式为644的文件，并且把他们增 加为可以执行的。 $find /data –type f –perm 644 –name *.sh –ok chmod 755 &#123;&#125; \\;","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"Linux基本命令","slug":"Linux基本命令","date":"2022-03-17T13:34:46.000Z","updated":"2022-03-23T14:04:13.421Z","comments":true,"path":"2022/03/17/Linux基本命令/","link":"","permalink":"http://example.com/2022/03/17/Linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/","excerpt":"","text":"Linux基本命令1.pwd：显示当前路径cd ：切换目录 用法：cdcd ../ 切换到上级目录cd / 切换到根目录cd ~ （或只有cd ）切换到当前用户主目录(home底下以用户名命名的文件夹) /root目录 mkdir 创建目录 mkdir 目录名 -p 递归创建目录 2.rmdir 删除空目录用法：rmdir 目录名也可用：rm -rf 目录名 3.ls 查看目录或文件信息主要选项：-l 列出目录或者文件的详细信息。比如权限、修改时间等等-a 列出当前目录下所有文件，包括隐藏文件（已点开头的都是隐藏文件） 4.vi 文本编辑器vim是vi的升级版,最常见的区别是能用多种颜色显示显示系统文件的一些特殊信息。 vi: Visual Interface 文本编辑器,可视化接口 vim：vi iMproved的缩写，即vi的增强版 vim编辑器分为三种主要模式： 命令模式（编辑模式）：默认模式，移动光标，剪切/粘贴文本（界面表现：左下角显示文件名或为空） 插入模式（输入模式）：修改文本（界面表现：左下角显示—INSERT–）插入模式下，按ESC按键返回命令模式 末行模式（扩展模式）：保存、退出等（界面表现：左下角显示—VISUAL–）末行模式下连续按两次ESC按键返回末行模式 Esc建Esc建：总是返回到命令模式退出编辑按ESC键不保存退出： :q!保存退出： :wq输入/，进入搜索输入:set nu，显示每一行的行数按键盘G，可以直接定位到最末尾 5.cp 复制用法：cp ［选项］文件名或目录 目标地址-R 拷贝目录及目录下所有目录和文件cp a.txt b.txt 将a文件复制，且另命名为b文件（目录名） 6.mv 移动用法：mv 文件名或目录 目标目录mv a.txt ../ 将a文件移动到上级目录（将一个文件移动到另一个目录没有重命名）mv a.txt ../b.txt 将a文件移动到上一级并改名为b文件（将一个文件移动到另一个目录并重命名） 7.rm 删除文件或目录-f 强制删除-r 删除目录常用：rm -rf 文件或目录 8.find 查找文件用法：find [路径] [选项]常用选项有：find . -name *.log 在当前目录查找以.log结尾的文件find / -name log 在根目录查找log命名的目录 9.grep 过滤在指定文件中查找字符（串）并打印该行用法：grep 字符串 文件名grep band file 在file文件中找寻band字符串 10.cat 显示文本文件内容用法：cat 文件名 cat 文件名字 11.head 查看前几行用法： head -n 5 文件名 12.tail 从指定点开始将文件写到标准输出tail -n 5 文件名 查看后几行tail -f error.log 不断刷新，看到最新内容 13.ps 查看进程（动态）-ef 显示所有运行进程，并显示启动进程的命令 14.netstat 查看网络状况 （net status的简写）netstat -apn 查看所有端口an，按一定顺序排列输出p，表示显示哪个进程在调用 15.| 管道符 （竖线，英文输入法状态下shift+键盘上的的|\\）在命令之间建立管道，将前面命令的输出作为后面命令的输入通过命令查找tomcat进程：ps -ef | grep tomcat通过命令查找到占用此端口的进程编号：netstat -apn|grep 8080 16.echo 打印文件内容或编辑文件内容常用选项有：-n 不换行输出-e 可以使用转义字符（\\n回车，\\t tab键）示例：echo “I am studying linux”&gt;&gt;xujun.txt 追加文件尾部内容echo $? 假如返回值为0的时候，表示上一次命令成功。假如是1到255的话，则是失败echo -e “wo\\tshi\\tshei”&gt; xujun.txt 17.touch 创建一个空白文件，假如当前目录有同样的文件，则会更新文件的时间戳-a 修改access（访问）时间-m 修改modify（修改）时间这两个参数了解即可 18.uname 查看系统-m 查看系统是几位操作系统-r 查看系统的内核版本-a 查看详细的系统内核版本和系统的操作系统 19.rz 上传假如系统里面没有这个命令，则使用yum install lrzsz 安装-y 覆盖直接输入rz，就可以上传文件 20.sz 下载假如系统里面没有这个命令，则使用yum install lrzsz 安装-y 覆盖sz -y test.txt 21.su 切换用户su root 从普通用户切换到root（或直接su） root状态切换其他用户直接su 用户名 22.history 查看命令历史记录23.chmod 权限赋予命令-R 递归改变目录下所有子目录和文件的权限数字方式：r=4 w=2 x=1 chmod 777 lemon 24.tar 解压，压缩tar.gztar -czvf test.tar.gz test 将test文件夹压缩成test.tar.gz tar -xzvf test.tar.gz 将test.tar.gz解压得到test文件夹 25.zip 解压，压缩zip zip –r test.zip test 将test文件夹压缩成test.zip，必须带r 才会把文件压缩进去，不然会生成一个空的文件夹 unzip test.zip 将test.zip文件夹解压 26.关闭防火墙开启：service iptables start关闭：service iptables stop 27. 从尾到头查看文件tac 28.shutdown 关机 永久关闭防火墙 shutdown是关闭系统poweroff是关闭系统的同时还关掉电源","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"}]},{"title":"Markdown基本语法","slug":"Markdown基本语法","date":"2022-03-05T04:31:11.000Z","updated":"2022-03-17T13:45:18.885Z","comments":true,"path":"2022/03/05/Markdown基本语法/","link":"","permalink":"http://example.com/2022/03/05/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","excerpt":"","text":"Markdown基本语法Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。 Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。 Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。 Markdown 编写的文档后缀为 .md, .markdown。 Markdown 应用Markdown 能被使用来撰写电子书，如：Gitbook。 当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。 优点：1、因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。2、操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可 缺点：1、需要记一些语法（很简单，五分钟学会）。2、有些平台不支持Markdown编辑模式。 1开启方式：设置-&gt;默认编辑器-&gt;Markdown编辑器 编辑器Typora、VScode、wolai等软件均支持markdown语法，本文在Typora上编写。 Markdown标题在想要设置为标题的文字前面加#来表示一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 注：标准语法一般在#后跟个空格再写文字。 示例： 123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 效果如下： 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题 Markdown字体 加粗 要加粗的文字左右分别用两个*号包起来 斜体 要倾斜的文字左右分别用一个*号包起来 斜体加粗 要倾斜和加粗的文字左右分别用三个*号包起来 删除线 要加删除线的文字左右分别用两个~~号包起来 示例： 1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ 效果如下： 这是加粗的文字这是倾斜的文字*这是斜体加粗的文字*这是加删除线的文字 Markdown区块在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个… 示例： 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果如下： 这是引用的内容 这是引用的内容 这是引用的内容 Markdown分割线三个或者三个以上的 - 或者 * 都可以。 示例： 1234-------******** 效果如下：可以看到，显示效果是一样的。 Markdown图片语法： 1234![图片alt](图片地址 &#x27;&#x27;图片title&#x27;&#x27;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： 12![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg &quot;区块链&quot;) 效果如下： 上传本地图片直接点击导航栏的图片标志，选择图片即可 markdown格式追求的是简单、多平台统一。那么图片的存储就是一个问题，需要用图床，提供统一的外链，这样就不用在不同的平台去处理图片的问题了。才能做到书写一次，各处使用。 Markdown超链接语法： 12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 示例： 12[知乎](http://zhihu.com)[百度](http://baidu.com) 效果如下： 知乎百度 注：Markdown本身语法不支持链接在新页面中打开，如果想要在新页面中打开的话可以用html语言的a标签代替。 1234&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt;示例&lt;a href=&quot;https://www.baidu.com&quot; target=&quot;_blank&quot;&gt;百度&lt;/a&gt; Markdown列表无序列表语法：无序列表用 - + * 任何一种都可以 12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 效果如下： 列表内容 列表内容 列表内容 有序列表语法：数字加点 123451. 列表内容2. 列表内容3. 列表内容注意：序号跟内容之间要有空格 效果如下： 列表内容 列表内容 列表内容 列表嵌套上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 Markdown表格语法： 1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 示例： 12345姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 效果如下： 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 这里有一个网站可以一键生成表格 https://www.tablesgenerator.com/markdown_tables Markdown代码语法：单行代码：代码之间分别用一个反引号包起来 1`代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 12345(```) 代码... 代码... 代码...(```) 注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。 示例： 单行代码 1`create database hero;` 代码块 123456(```) function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;; &#125; fun();(```) 效果如下： 单行代码 1create database hero; 代码块 1234function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;;&#125;fun(); Markdown流程图123456789```flowst=&gt;start: 开始op=&gt;operation: My Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op&amp;``` 效果如下： Markdown 其他技巧支持HTML 元素不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。 目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等 ，如： 1使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑 公式Markdown Preview Enhanced 使用 KaTeX 或者 MathJax 来渲染数学表达式。 KaTeX 拥有比 MathJax 更快的性能，但是它却少了很多 MathJax 拥有的特性。你可以查看 KaTeX supported functions/symbols 来了解 KaTeX 支持那些符号和函数。 默认下的分隔符： $...$ 或者 \\(...\\) 中的数学表达式将会在行内显示。 $$...$$ 或者 \\[...\\] 或者 ````math` 中的数学表达式将会在块内显示。 12345678910111213$$\\begin&#123;Bmatrix&#125; a &amp; b \\\\ c &amp; d\\end&#123;Bmatrix&#125;$$$$\\begin&#123;CD&#125; A @&gt;a&gt;&gt; B \\\\@VbVV @AAcA \\\\ C @= D\\end&#123;CD&#125;$$ 输出结果为：","categories":[],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://example.com/tags/Markdown/"}]},{"title":"CentOS7启动与切换图形界面","slug":"CentOS7启动与切换图形界面","date":"2022-03-02T14:25:40.000Z","updated":"2022-04-21T05:00:37.172Z","comments":true,"path":"2022/03/02/CentOS7启动与切换图形界面/","link":"","permalink":"http://example.com/2022/03/02/CentOS7%E5%90%AF%E5%8A%A8%E4%B8%8E%E5%88%87%E6%8D%A2%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/","excerpt":"","text":"Cent OS 7 启动与切换图形界面安装图形界面默认情况下是不会安装图形界面的，所以需要自己手动安装，步骤如下： 开启系统，以root身份进入 安装X(X Window System)，命令如下： 1yum groupinstall &quot;X Window System&quot; 其中大约有200多个软件，安装完成会出现complete！字样。然后安装图形界面软件，命令如下： 1yum groupinstall &quot;GNOME Desktop&quot; 由于这个软件组比第一个要大很多（包含800个左右的软件），安装过程会比较慢。安装完成会出现complete！字样。 安装完成后我们可以通过命令 startx 进入图形界面 开机启动图形化界面 首先使用ctrl+alt+f2切换到命令行模式，如果本身就是命令行模式就直接看下面的步骤 然后输入如下命令，查看当前开机启动模式 1systemctl get-default graphical.target代表开机时启动图形化界面multi-user.target代表开机时启动dos界面 最后输入如下命令设置开机启动图形界面 1systemctl set-default graphical.target 同理，如果想开机启动dos界面，就输入如下命令 1systemctl set-default multi-user.target dos界面与图形化界面切换快捷键图形到dos：ctrl+alt+f2dos到图形：输入startx或者在命令上输入 init 3 命令 切换到dos界面输入 init 5命令 切换到图形界面 无法下载X Window System 与GNOME Desktop 检查网络 ping www.baidu.com 若无法ping通，则修改网络配置 1234#cd /etc#cd sysconfig#cd network-scripts#vi ifcfg-ens33 修改ifcfg-ens33文件的最后一条，将ONEBOOT：no 的no修改为yes，esc ：wq 保存退出 重启网络服务并重启系统 123#service network restart#init 6 安装图形化桌面 1234yum groupinstall “X Window System”yum groupinstall “GNOME Desktop”systemctl set-default graphical.targetstartx","categories":[],"tags":[{"name":"centOS","slug":"centOS","permalink":"http://example.com/tags/centOS/"},{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]},{"title":"Hello World","slug":"Hello World","date":"2022-01-06T02:42:00.000Z","updated":"2022-03-05T04:38:08.870Z","comments":true,"path":"2022/01/06/Hello World/","link":"","permalink":"http://example.com/2022/01/06/Hello%20World/","excerpt":"","text":"Hello WorldWelcome to Hexo! This is your very first post. 这里是Args建立的第一个个人博客 20计算机科学与技术三班张吉涛 Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"Docker","slug":"Docker","permalink":"http://example.com/tags/Docker/"},{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"},{"name":"java","slug":"java","permalink":"http://example.com/tags/java/"},{"name":"Markdown","slug":"Markdown","permalink":"http://example.com/tags/Markdown/"},{"name":"centOS","slug":"centOS","permalink":"http://example.com/tags/centOS/"},{"name":"教程","slug":"教程","permalink":"http://example.com/tags/%E6%95%99%E7%A8%8B/"}]}